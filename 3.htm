<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>真實時間軌跡計數器</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js (使用穩定的 UMD 版本) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f3f4f6;
        }
        .touch-manipulation {
            touch-action: manipulation;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div class="bg-white w-full max-w-md rounded-2xl shadow-xl overflow-hidden flex flex-col">
        <!-- Header -->
        <div class="bg-indigo-600 p-4 text-white text-center shadow-md z-10">
            <h1 class="text-xl font-bold tracking-wider">速度軌跡計數器</h1>
        </div>

        <!-- Settings Section -->
        <div class="p-4 bg-indigo-50 border-b border-indigo-100 space-y-4">
            <!-- Row 1: Start & End -->
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">開始數字</label>
                    <input type="number" id="startInput" class="w-full p-2 rounded border border-indigo-200 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg font-mono" placeholder="例如: 0">
                </div>
                <div>
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">結束數字 (目標)</label>
                    <input type="number" id="endInput" class="w-full p-2 rounded border border-indigo-200 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg font-mono" placeholder="例如: 150">
                </div>
            </div>
            
            <!-- Row 2: Total Duration & Target Time -->
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">總時長 (DDHHMM)</label>
                    <input type="text" id="totalDurationInput" class="w-full p-2 rounded border border-indigo-200 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg font-mono" placeholder="例如 020000">
                    <div class="text-[10px] text-gray-400 mt-1 text-center truncate">020000 代表 2天整</div>
                </div>
                <div class="relative">
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">目標時間 (截止)</label>
                    <input type="text" id="targetTimeInput" class="w-full p-2 rounded border border-indigo-200 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg font-mono" placeholder="HHMM">
                    <div id="targetTimeHint" class="text-[10px] text-gray-400 mt-1 text-center truncate h-4"></div>
                </div>
            </div>

            <!-- Prediction Badge (Full Width) -->
            <div id="predictionBadge" class="hidden w-full bg-purple-100 text-purple-700 px-3 py-2 rounded-lg text-sm font-bold border border-purple-200 text-center flex flex-col gap-1">
                <div class="flex justify-between w-full">
                    <span>預測抵達目標時:</span>
                    <span id="predictedNumber" class="text-lg">--</span>
                </div>
                <div id="calculatedElapsedHint" class="text-[10px] text-purple-400 text-right w-full border-t border-purple-200 pt-1 mt-1">
                    <!-- Javascript will fill this: 已使用時間: 1天05時... -->
                </div>
            </div>
        </div>

        <!-- Main Display -->
        <div class="flex-grow p-6 flex flex-col items-center justify-center space-y-2 relative">
            
            <!-- Timer Display -->
            <div class="absolute top-4 right-4 text-xs font-mono text-gray-400 text-right">
                <div>本次計時: <span id="timerDisplay">00:00:00</span></div>
            </div>

            <!-- Remaining Count (Conditional) -->
            <div id="remainingSection" class="hidden w-full mb-2 mt-6">
                 <div class="flex justify-between items-end mb-1 px-1">
                    <span class="text-xs font-bold text-gray-400">進度</span>
                    <span class="text-xs font-bold text-indigo-600">剩餘: <span id="remainingDisplay">0</span></span>
                 </div>
                 <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                  </div>
            </div>

            <!-- Current Number Big Display -->
            <div class="text-center py-4">
                <div class="text-sm text-gray-400 mb-1 uppercase tracking-widest">目前數字</div>
                <div id="currentNumberDisplay" class="text-8xl font-black text-gray-800 transition-all transform duration-75 leading-none">0</div>
            </div>
        </div>

        <!-- Button Section -->
        <div class="px-6 pb-2">
            <button id="incrementBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 active:bg-indigo-800 text-white font-bold py-6 rounded-2xl shadow-lg shadow-indigo-200 text-3xl touch-manipulation transition-all transform active:scale-95 flex items-center justify-center gap-2">
                <span>+1</span>
                <span class="text-sm font-normal opacity-70">(點擊增加)</span>
            </button>
        </div>

        <div class="px-6 pb-4 pt-2 flex justify-between items-center">
            <button onclick="resetData()" class="text-xs text-red-400 hover:text-red-600 py-2 px-4 rounded border border-transparent hover:border-red-100 transition-colors">↺ 重置紀錄</button>
            <button onclick="applySettings()" class="text-xs font-bold text-indigo-500 hover:text-indigo-700 py-2 px-4 rounded bg-indigo-50 hover:bg-indigo-100 transition-colors">更新設定</button>
        </div>

        <!-- Chart Section -->
        <div class="bg-gray-50 p-4 border-t border-gray-200 h-48">
            <div class="flex justify-between items-center mb-1">
                <h3 class="text-[10px] font-bold text-gray-400 uppercase">增加速度曲線 (實線:目前 / 虛線:預測)</h3>
            </div>
            <div class="h-full w-full pb-4">
                <canvas id="progressChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- 狀態管理 ---
        const STORAGE_KEY = 'counter_app_v5_total_duration';
        
        let state = {
            start: 0,
            current: 0,
            end: null, 
            targetTimeStr: '', 
            totalDurationStr: '', // "020000" (2 days)
            startTime: null, // timestamp of THIS session start
            history: [] 
        };

        // --- Chart.js 實例 ---
        let chartInstance = null;

        // --- 初始化 ---
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
            initChart();
            renderUI();
            
            // 啟動計時器更新循環 (每秒更新顯示與預測)
            setInterval(() => {
                updateTimerDisplay();
                updatePrediction(); 
            }, 1000);
        });

        // --- 核心邏輯 ---

        function loadData() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    state = { ...state, ...parsed };
                    
                    // 填回 Input
                    document.getElementById('startInput').value = state.start;
                    if(state.end !== null) {
                        document.getElementById('endInput').value = state.end;
                    }
                    if(state.targetTimeStr) {
                        document.getElementById('targetTimeInput').value = state.targetTimeStr;
                    }
                    // 兼容舊版 elapsedStr 或新版 totalDurationStr
                    if(state.totalDurationStr) {
                        document.getElementById('totalDurationInput').value = state.totalDurationStr;
                    } else if (parsed.elapsedStr) {
                        // 如果有舊的資料，暫時不填入，因為邏輯變了
                    }
                } catch (e) {
                    console.error("讀取資料失敗", e);
                }
            } else {
                document.getElementById('startInput').value = 0;
                state.current = 0;
            }
        }

        function saveData() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        function applySettings() {
            const startVal = parseInt(document.getElementById('startInput').value) || 0;
            const endValInput = document.getElementById('endInput').value;
            const endVal = endValInput === '' ? null : parseInt(endValInput);
            const targetTimeStr = document.getElementById('targetTimeInput').value.trim();
            const totalDurationStr = document.getElementById('totalDurationInput').value.trim();

            if (state.history.length === 0 || state.current < startVal) {
                state.current = startVal;
            }

            state.start = startVal;
            state.end = endVal;
            state.targetTimeStr = targetTimeStr;
            state.totalDurationStr = totalDurationStr;
            
            saveData();
            renderUI();
            
            const btn = document.querySelector('button[onclick="applySettings()"]');
            const originalText = btn.innerText;
            btn.innerText = "已更新!";
            setTimeout(() => btn.innerText = originalText, 1000);
        }

        document.getElementById('incrementBtn').addEventListener('click', () => {
            const now = Date.now();

            if (!state.startTime) {
                state.startTime = now;
                if (state.history.length === 0) {
                    state.history.push({ t: now, v: state.current });
                }
            }

            state.current++;

            state.history.push({
                t: now,
                v: state.current
            });

            // 動畫
            const display = document.getElementById('currentNumberDisplay');
            display.style.transform = "scale(1.1)";
            display.style.color = "#4f46e5"; 
            setTimeout(() => {
                display.style.transform = "scale(1)";
                display.style.color = "#1f2937";
            }, 100);

            saveData();
            renderUI();
        });

        function resetData() {
            if(confirm('確定要清除所有進度並重置嗎？\n(設定值會保留，但計數與圖表會清空)')) {
                state = {
                    start: parseInt(document.getElementById('startInput').value) || 0,
                    current: parseInt(document.getElementById('startInput').value) || 0,
                    end: null,
                    targetTimeStr: document.getElementById('targetTimeInput').value,
                    totalDurationStr: document.getElementById('totalDurationInput').value,
                    startTime: null,
                    history: []
                };
                
                localStorage.removeItem(STORAGE_KEY);
                renderUI();
            }
        }

        // --- 輔助函數 ---

        function parseTargetTimestamp(inputStr) {
            if (!inputStr) return null;
            let clean = inputStr.replace(/[^0-9]/g, '');
            if (clean.length === 3) clean = '0' + clean;
            if (clean.length !== 4) return null;

            const hh = parseInt(clean.substring(0, 2));
            const mm = parseInt(clean.substring(2, 4));
            if (hh > 23 || mm > 59) return null;

            const now = new Date();
            const target = new Date();
            target.setHours(hh, mm, 0, 0);

            // 如果該時間點已經過了，預設是明天
            // (除非使用者真的要設今天的過去時間，但通常是設截止時間)
            if (target.getTime() <= now.getTime()) {
                target.setDate(target.getDate() + 1);
            }
            return target.getTime();
        }

        // 解析 DDHHMM 或 HHMM 為毫秒
        function parseDurationStr(str) {
            if (!str) return 0;
            let s = str.replace(/[^0-9]/g, '');
            if (s.length === 0) return 0;

            let d = 0, h = 0, m = 0;

            if (s.length <= 4) {
                // HHMM
                m = parseInt(s.slice(-2));
                if (s.length > 2) {
                    h = parseInt(s.slice(0, -2));
                }
            } else {
                // DDHHMM
                m = parseInt(s.slice(-2));
                h = parseInt(s.slice(-4, -2));
                d = parseInt(s.slice(0, -4));
            }

            return ((d * 24 + h) * 60 + m) * 60 * 1000;
        }

        function formatDuration(ms) {
            if (ms < 0) ms = 0;
            const totalSec = Math.floor(ms / 1000);
            const d = Math.floor(totalSec / (3600 * 24));
            const h = Math.floor((totalSec % (3600 * 24)) / 3600);
            const m = Math.floor((totalSec % 3600) / 60);
            const s = totalSec % 60;
            
            const pad = (n) => n.toString().padStart(2, '0');
            
            if (d > 0) return `${d}天 ${pad(h)}:${pad(m)}:${pad(s)}`;
            return `${pad(h)}:${pad(m)}:${pad(s)}`;
        }

        // --- UI 渲染與預測邏輯 ---

        function updatePrediction() {
            const targetTs = parseTargetTimestamp(state.targetTimeStr);
            const totalDurationMs = parseDurationStr(state.totalDurationStr);
            const badge = document.getElementById('predictionBadge');
            const hint = document.getElementById('targetTimeHint');
            const calculatedHint = document.getElementById('calculatedElapsedHint');
            
            // 目標時間文字提示
            if (targetTs) {
                hint.innerText = `目標: ${new Date(targetTs).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`;
            } else {
                hint.innerText = '';
            }

            // 如果沒有足夠資訊，隱藏預測
            // 必須要有目標時間，且 (有總時長 OR 已經開始計時)
            if (!targetTs || (!totalDurationMs && (!state.startTime || state.history.length < 1))) {
                badge.classList.add('hidden');
                if(chartInstance && chartInstance.data.datasets[1]) {
                    chartInstance.data.datasets[1].data = [];
                    chartInstance.update('none');
                }
                return;
            }

            const now = Date.now();
            const sessionElapsed = state.startTime ? (now - state.startTime) : 0;
            
            // --- 核心邏輯：計算「已經歷時間 (Effective Elapsed)」 ---
            let effectiveElapsed = 0;

            // 1. 如果有設定總時長，則使用倒扣邏輯
            //    總時長 - (目標時間 - 現在) = 從開始到現在的總時間
            if (totalDurationMs > 0 && targetTs) {
                const timeRemaining = targetTs - now;
                effectiveElapsed = totalDurationMs - timeRemaining;
                
                // 顯示計算出來的經歷時間給使用者確認
                calculatedHint.innerText = `已使用總時間: ${formatDuration(effectiveElapsed)}`;
                
                // 防呆：如果還沒到開始時間 (effectiveElapsed < 0)，速率無法計算
                if (effectiveElapsed <= 0) effectiveElapsed = 0;
            } 
            // 2. 如果沒設定總時長，則退回使用「本次 Session 時間」
            else if (sessionElapsed > 0) {
                 // 這裡只算本次增量
                 // 但為了保持一致性，如果只依賴 Session，我們通常無法得知 Past Context
                 // 所以這種情況下 rate 計算會使用 sessionGained
                 effectiveElapsed = sessionElapsed;
                 calculatedHint.innerText = `僅計算本次時間`;
            }

            // 計算距離目標還有多久
            const msUntilTarget = targetTs - now;

            if (msUntilTarget <= 0) {
                badge.classList.remove('hidden');
                document.getElementById('predictedNumber').innerText = "時間到";
                return;
            }

            // --- 速率計算 ---
            let rate = 0; // items per ms
            
            if (effectiveElapsed > 0) {
                if (totalDurationMs > 0) {
                    // 如果是用總時長推算的，分母是「從專案開始到現在」
                    // 分子應該是「目前的總進度 (state.current)」
                    // 假設總時長是對應整個 state.current 的累積過程
                    rate = state.current / effectiveElapsed;
                } else {
                    // 如果只有本次 session，分子是「本次增量」
                    const sessionGained = state.current - state.start;
                    rate = sessionGained / sessionElapsed;
                }
            }

            // 預測增加量
            const predictedGain = rate * msUntilTarget;
            const predictedTotal = Math.floor(state.current + predictedGain);

            // UI 顯示
            badge.classList.remove('hidden');
            document.getElementById('predictedNumber').innerText = predictedTotal;

            // 更新圖表虛線
            updateChartPredictionLine(now, targetTs, state.current, predictedTotal);
        }

        function renderUI() {
            document.getElementById('currentNumberDisplay').innerText = state.current;

            let endVal = state.end; 
            const endInputVal = document.getElementById('endInput').value;
            if(endInputVal !== '') endVal = parseInt(endInputVal);

            const remainingSection = document.getElementById('remainingSection');
            
            if (endVal !== null && !isNaN(endVal)) {
                remainingSection.classList.remove('hidden');
                
                const totalRange = endVal - state.start;
                const progress = state.current - state.start;
                const remaining = endVal - state.current;

                document.getElementById('remainingDisplay').innerText = remaining;
                
                let percent = 0;
                if (totalRange > 0) {
                    percent = (progress / totalRange) * 100;
                    if (percent > 100) percent = 100;
                    if (percent < 0) percent = 0;
                }
                document.getElementById('progressBar').style.width = `${percent}%`;

                if (remaining <= 0) {
                     document.getElementById('remainingDisplay').innerText = "完成";
                     document.getElementById('remainingDisplay').parentElement.classList.add('text-green-500');
                     document.getElementById('progressBar').classList.add('bg-green-500');
                     document.getElementById('progressBar').classList.remove('bg-indigo-600');
                } else {
                     document.getElementById('remainingDisplay').parentElement.classList.remove('text-green-500');
                     document.getElementById('progressBar').classList.remove('bg-green-500');
                     document.getElementById('progressBar').classList.add('bg-indigo-600');
                }
            } else {
                remainingSection.classList.add('hidden');
            }

            updateTimerDisplay();
            updateChartData();
            updatePrediction();
        }

        function updateTimerDisplay() {
            const timerEl = document.getElementById('timerDisplay');
            
            if (!state.startTime) {
                timerEl.innerText = "00:00:00";
                return;
            }

            const now = Date.now();
            const sessionMs = now - state.startTime;
            timerEl.innerText = formatDuration(sessionMs);
        }

        // --- 圖表邏輯 ---

        function initChart() {
             if (typeof Chart === 'undefined') {
                console.error('Chart.js Library not loaded yet.');
                return;
            }
            const ctx = document.getElementById('progressChart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: '實際進度',
                            data: [],
                            borderColor: '#4f46e5',
                            backgroundColor: 'rgba(79, 70, 229, 0.1)',
                            borderWidth: 2,
                            tension: 0.1,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        },
                        {
                            label: '預測趨勢',
                            data: [],
                            borderColor: '#9333ea',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false,
                            tension: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `第 ${context[0].parsed.x.toFixed(0)} 秒`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: '本次經過時間 (秒)', font: { size: 10 } },
                            ticks: { maxTicksLimit: 6, font: { size: 10 } }
                        },
                        y: {
                            beginAtZero: false,
                            title: { display: true, text: '數字', font: { size: 10 } }
                        }
                    }
                }
            });
        }

        function updateChartData() {
            if (!chartInstance) return;
            if (state.history.length === 0) {
                chartInstance.data.datasets[0].data = [];
                chartInstance.update();
                return;
            }

            const startT = state.startTime;
            const dataPoints = state.history.map(pt => ({
                x: (pt.t - startT) / 1000, 
                y: pt.v
            }));

            chartInstance.data.datasets[0].data = dataPoints;
            chartInstance.update();
        }

        function updateChartPredictionLine(now, targetTs, currentVal, predictedVal) {
            if (!chartInstance || !state.startTime) return;
            
            const currentX = (now - state.startTime) / 1000;
            const targetX = (targetTs - state.startTime) / 1000;
            
            const predictionPoints = [
                { x: currentX, y: currentVal },
                { x: targetX, y: predictedVal }
            ];

            chartInstance.data.datasets[1].data = predictionPoints;
            chartInstance.update('none');
        }

    </script>
</body>
</html>
