<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>真實時間軌跡計數器</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js (使用穩定的 UMD 版本) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f3f4f6;
        }
        .touch-manipulation {
            touch-action: manipulation;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div class="bg-white w-full max-w-md rounded-2xl shadow-xl overflow-hidden flex flex-col">
        <!-- Header -->
        <div class="bg-indigo-600 p-4 text-white text-center shadow-md z-10">
            <h1 class="text-xl font-bold tracking-wider">速度軌跡計數器</h1>
        </div>

        <!-- Settings Section -->
        <div class="p-4 bg-indigo-50 border-b border-indigo-100 space-y-4">
            <!-- Row 1: Start & End -->
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">開始數字</label>
                    <input type="number" id="startInput" class="w-full p-2 rounded border border-indigo-200 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg font-mono" placeholder="例如: 0">
                </div>
                <div>
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">結束數字 (目標)</label>
                    <input type="number" id="endInput" class="w-full p-2 rounded border border-indigo-200 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg font-mono" placeholder="例如: 150">
                </div>
            </div>
            
            <!-- Row 2: Total Duration & Remaining Time -->
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">總時長 (DDHHMM)</label>
                    <input type="text" id="totalDurationInput" class="w-full p-2 rounded border border-indigo-200 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg font-mono" placeholder="例如 020000">
                    <div class="text-[10px] text-gray-400 mt-1 text-center truncate">020000 代表 2天整</div>
                </div>
                <div class="relative">
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">剩餘時間 (DDHHMM)</label>
                    <input type="text" id="remainingTimeInput" class="w-full p-2 rounded border border-indigo-200 text-center focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg font-mono" placeholder="例如 010000">
                    <div id="remainingTimeHint" class="text-[10px] text-gray-400 mt-1 text-center truncate h-4"></div>
                </div>
            </div>

            <!-- Prediction Badge (Full Width) -->
            <div id="predictionBadge" class="hidden w-full bg-purple-100 text-purple-700 px-3 py-2 rounded-lg text-sm font-bold border border-purple-200 text-center flex flex-col gap-1">
                <div class="flex justify-between w-full">
                    <span>預測抵達目標時:</span>
                    <span id="predictedNumber" class="text-lg">--</span>
                </div>
                <div id="calculatedElapsedHint" class="text-[10px] text-purple-400 text-right w-full border-t border-purple-200 pt-1 mt-1">
                    <!-- Javascript will fill this: 已使用時間: ... -->
                </div>
            </div>
        </div>

        <!-- Main Display -->
        <div class="flex-grow p-6 flex flex-col items-center justify-center space-y-2 relative">
            
            <!-- Timer Display -->
            <div class="absolute top-4 right-4 text-xs font-mono text-gray-400 text-right">
                <div>本次計時: <span id="timerDisplay">00:00:00</span></div>
            </div>

            <!-- Remaining Count (Conditional) -->
            <div id="remainingSection" class="hidden w-full mb-2 mt-6">
                 <div class="flex justify-between items-end mb-1 px-1">
                    <span class="text-xs font-bold text-gray-400">進度</span>
                    <span class="text-xs font-bold text-indigo-600">剩餘: <span id="remainingDisplay">0</span></span>
                 </div>
                 <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                  </div>
            </div>

            <!-- Current Number Big Display -->
            <div class="text-center py-4">
                <div class="text-sm text-gray-400 mb-1 uppercase tracking-widest">目前數字</div>
                <div id="currentNumberDisplay" class="text-8xl font-black text-gray-800 transition-all transform duration-75 leading-none">0</div>
            </div>
        </div>

        <!-- Button Section -->
        <div class="px-6 pb-2">
            <button id="incrementBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 active:bg-indigo-800 text-white font-bold py-6 rounded-2xl shadow-lg shadow-indigo-200 text-3xl touch-manipulation transition-all transform active:scale-95 flex items-center justify-center gap-2">
                <span>+1</span>
                <span class="text-sm font-normal opacity-70">(點擊增加)</span>
            </button>
        </div>

        <div class="px-6 pb-4 pt-2 flex justify-between items-center">
            <button onclick="resetData()" class="text-xs text-red-400 hover:text-red-600 py-2 px-4 rounded border border-transparent hover:border-red-100 transition-colors">↺ 重置紀錄</button>
            <button onclick="applySettings()" class="text-xs font-bold text-indigo-500 hover:text-indigo-700 py-2 px-4 rounded bg-indigo-50 hover:bg-indigo-100 transition-colors">更新設定</button>
        </div>

        <!-- Chart Section -->
        <div class="bg-gray-50 p-4 border-t border-gray-200 h-48">
            <div class="flex justify-between items-center mb-1">
                <h3 class="text-[10px] font-bold text-gray-400 uppercase">增加速度曲線 (實線:過去 / 虛線:預測)</h3>
            </div>
            <div class="h-full w-full pb-4">
                <canvas id="progressChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- 狀態管理 ---
        const STORAGE_KEY = 'counter_app_v6_remaining_fix';
        
        let state = {
            start: 0,
            current: 0,
            end: null, 
            remainingTimeStr: '', // Changed from targetTimeStr
            totalDurationStr: '', // "020000" (2 days)
            startTime: null, // timestamp of THIS session start
            history: [] 
        };

        // --- Chart.js 實例 ---
        let chartInstance = null;

        // --- 初始化 ---
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
            initChart();
            renderUI();
            
            // 啟動計時器更新循環 (每秒更新顯示與預測)
            setInterval(() => {
                updateTimerDisplay();
                updatePredictionAndChart(); 
            }, 1000);
        });

        // --- 核心邏輯 ---

        function loadData() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    state = { ...state, ...parsed };
                    
                    document.getElementById('startInput').value = state.start;
                    if(state.end !== null) {
                        document.getElementById('endInput').value = state.end;
                    }
                    if(state.remainingTimeStr) {
                        document.getElementById('remainingTimeInput').value = state.remainingTimeStr;
                    } else if (state.targetTimeStr) {
                         // Migration for old data key
                        document.getElementById('remainingTimeInput').value = state.targetTimeStr;
                    }
                    if(state.totalDurationStr) {
                        document.getElementById('totalDurationInput').value = state.totalDurationStr;
                    }
                } catch (e) {
                    console.error("讀取資料失敗", e);
                }
            } else {
                document.getElementById('startInput').value = 0;
                state.current = 0;
            }
        }

        function saveData() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        function applySettings() {
            const startVal = parseInt(document.getElementById('startInput').value) || 0;
            const endValInput = document.getElementById('endInput').value;
            const endVal = endValInput === '' ? null : parseInt(endValInput);
            const remainingTimeStr = document.getElementById('remainingTimeInput').value.trim();
            const totalDurationStr = document.getElementById('totalDurationInput').value.trim();

            if (state.history.length === 0 || state.current < startVal) {
                state.current = startVal;
            }

            state.start = startVal;
            state.end = endVal;
            state.remainingTimeStr = remainingTimeStr;
            state.totalDurationStr = totalDurationStr;
            
            saveData();
            renderUI();
            
            const btn = document.querySelector('button[onclick="applySettings()"]');
            const originalText = btn.innerText;
            btn.innerText = "已更新!";
            setTimeout(() => btn.innerText = originalText, 1000);
        }

        document.getElementById('incrementBtn').addEventListener('click', () => {
            const now = Date.now();

            if (!state.startTime) {
                state.startTime = now;
                if (state.history.length === 0) {
                    state.history.push({ t: now, v: state.current });
                }
            }

            state.current++;

            state.history.push({
                t: now,
                v: state.current
            });

            const display = document.getElementById('currentNumberDisplay');
            display.style.transform = "scale(1.1)";
            display.style.color = "#4f46e5"; 
            setTimeout(() => {
                display.style.transform = "scale(1)";
                display.style.color = "#1f2937";
            }, 100);

            saveData();
            renderUI();
        });

        function resetData() {
            if(confirm('確定要清除所有進度並重置嗎？\n(設定值會保留，但計數與圖表會清空)')) {
                state = {
                    start: parseInt(document.getElementById('startInput').value) || 0,
                    current: parseInt(document.getElementById('startInput').value) || 0,
                    end: null,
                    remainingTimeStr: document.getElementById('remainingTimeInput').value,
                    totalDurationStr: document.getElementById('totalDurationInput').value,
                    startTime: null,
                    history: []
                };
                
                localStorage.removeItem(STORAGE_KEY);
                renderUI();
            }
        }

        // --- 輔助函數 ---

        function parseDurationStr(str) {
            if (!str) return 0;
            let s = str.replace(/[^0-9]/g, '');
            if (s.length === 0) return 0;

            let d = 0, h = 0, m = 0;

            if (s.length <= 4) {
                m = parseInt(s.slice(-2));
                if (s.length > 2) h = parseInt(s.slice(0, -2));
            } else {
                m = parseInt(s.slice(-2));
                h = parseInt(s.slice(-4, -2));
                d = parseInt(s.slice(0, -4));
            }
            return ((d * 24 + h) * 60 + m) * 60 * 1000;
        }

        function formatDuration(ms) {
            if (ms < 0) ms = 0;
            const totalSec = Math.floor(ms / 1000);
            const d = Math.floor(totalSec / (3600 * 24));
            const h = Math.floor((totalSec % (3600 * 24)) / 3600);
            const m = Math.floor((totalSec % 3600) / 60);
            const s = totalSec % 60;
            
            const pad = (n) => n.toString().padStart(2, '0');
            
            if (d > 0) return `${d}天 ${pad(h)}:${pad(m)}:${pad(s)}`;
            return `${pad(h)}:${pad(m)}:${pad(s)}`;
        }

        // --- UI 渲染與預測邏輯 ---

        function updatePredictionAndChart() {
            const totalDurationMs = parseDurationStr(state.totalDurationStr);
            const remainingDurationMs = parseDurationStr(state.remainingTimeStr); // 這是使用者輸入的「剩餘時間長度」
            
            const badge = document.getElementById('predictionBadge');
            const hint = document.getElementById('remainingTimeHint');
            const calculatedHint = document.getElementById('calculatedElapsedHint');
            
            // 提示剩餘時間
            if (remainingDurationMs > 0) {
                hint.innerText = `設定剩餘: ${formatDuration(remainingDurationMs)}`;
            } else {
                hint.innerText = '';
            }

            // 判斷是否具備預測條件
            // 必須要有總時長
            const hasData = totalDurationMs > 0;

            if (!hasData) {
                badge.classList.add('hidden');
                if(chartInstance && chartInstance.data.datasets[1].data.length > 0) {
                    chartInstance.data.datasets[1].data = [];
                    chartInstance.update('none');
                }
                updateChartMainLine(0, 0, 0); 
                return;
            }

            const now = Date.now();
            let sessionElapsedMs = state.startTime ? (now - state.startTime) : 0;
            
            // --- 核心邏輯：計算「已使用時間 (Past Elapsed)」 ---
            // 公式：已使用時間 = 總時長 - 設定的剩餘時間
            // 這是「在此次 Session 開始前」或「現在」的狀態
            // 注意：因為時間在走，"設定的剩餘時間" 是靜態的輸入值
            // 所以我們將其視為 "設定當下" 或 "Session 開始前" 的狀態
            
            let pastElapsedMs = 0;
            if (remainingDurationMs > 0 && totalDurationMs >= remainingDurationMs) {
                pastElapsedMs = totalDurationMs - remainingDurationMs;
            }
            
            // 總共經過時間 = 過去已使用 + 本次 Session
            const totalElapsedMs = pastElapsedMs + sessionElapsedMs;
            
            calculatedHint.innerText = `已使用總時間: ${formatDuration(totalElapsedMs)}`;

            // 實際剩餘時間 (動態) = 總時長 - 總經過時間
            const actualRemainingMs = totalDurationMs - totalElapsedMs;

            // 處理時間到
            if (actualRemainingMs <= 0) {
                badge.classList.remove('hidden');
                document.getElementById('predictedNumber').innerText = "時間到";
                updateChartMainLine(pastElapsedMs, sessionElapsedMs, totalElapsedMs);
                if(chartInstance) {
                     chartInstance.data.datasets[1].data = [];
                     chartInstance.update('none');
                }
                return;
            }

            // --- 速率與預測計算 ---
            let rate = 0; 
            if (totalElapsedMs > 0) {
                // 原點是 (0, 0)。
                // 現在點是 (totalElapsedMs, state.current)。
                // 速率 = 目前總數 / 目前總時間
                rate = state.current / totalElapsedMs;
            }

            const predictedGain = rate * actualRemainingMs;
            const predictedTotal = Math.floor(state.current + predictedGain);

            badge.classList.remove('hidden');
            document.getElementById('predictedNumber').innerText = predictedTotal;

            // --- 更新圖表 ---
            // 1. 更新實線
            updateChartMainLine(pastElapsedMs, sessionElapsedMs, totalElapsedMs);
            
            // 2. 更新虛線 (從現在到結束)
            const currentX = totalElapsedMs / 1000;
            const endX = totalDurationMs / 1000;
            
            if (chartInstance) {
                const predictionPoints = [
                    { x: currentX, y: state.current },
                    { x: endX, y: predictedTotal }
                ];
                chartInstance.data.datasets[1].data = predictionPoints;
                chartInstance.update('none');
            }
        }

        function renderUI() {
            document.getElementById('currentNumberDisplay').innerText = state.current;

            let endVal = state.end; 
            const endInputVal = document.getElementById('endInput').value;
            if(endInputVal !== '') endVal = parseInt(endInputVal);

            const remainingSection = document.getElementById('remainingSection');
            
            if (endVal !== null && !isNaN(endVal)) {
                remainingSection.classList.remove('hidden');
                
                const totalRange = endVal - state.start;
                const progress = state.current - state.start;
                const remaining = endVal - state.current;

                document.getElementById('remainingDisplay').innerText = remaining;
                
                let percent = 0;
                if (totalRange > 0) {
                    percent = (progress / totalRange) * 100;
                    if (percent > 100) percent = 100;
                    if (percent < 0) percent = 0;
                }
                document.getElementById('progressBar').style.width = `${percent}%`;

                if (remaining <= 0) {
                     document.getElementById('remainingDisplay').innerText = "完成";
                     document.getElementById('remainingDisplay').parentElement.classList.add('text-green-500');
                     document.getElementById('progressBar').classList.add('bg-green-500');
                     document.getElementById('progressBar').classList.remove('bg-indigo-600');
                } else {
                     document.getElementById('remainingDisplay').parentElement.classList.remove('text-green-500');
                     document.getElementById('progressBar').classList.remove('bg-green-500');
                     document.getElementById('progressBar').classList.add('bg-indigo-600');
                }
            } else {
                remainingSection.classList.add('hidden');
            }

            updateTimerDisplay();
            updatePredictionAndChart();
        }

        function updateTimerDisplay() {
            const timerEl = document.getElementById('timerDisplay');
            if (!state.startTime) {
                timerEl.innerText = "00:00:00";
                return;
            }
            const now = Date.now();
            const sessionMs = now - state.startTime;
            timerEl.innerText = formatDuration(sessionMs);
        }

        // --- 圖表邏輯 ---

        function initChart() {
             if (typeof Chart === 'undefined') {
                console.error('Chart.js Library not loaded yet.');
                return;
            }
            const ctx = document.getElementById('progressChart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: '實際進度',
                            data: [],
                            borderColor: '#4f46e5',
                            backgroundColor: 'rgba(79, 70, 229, 0.1)',
                            borderWidth: 2,
                            tension: 0.1,
                            fill: true,
                            pointRadius: 3, 
                            pointHoverRadius: 5
                        },
                        {
                            label: '預測趨勢',
                            data: [],
                            borderColor: '#9333ea',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false,
                            tension: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    // 格式化 X 軸時間顯示
                                    const sec = context[0].parsed.x;
                                    const h = Math.floor(sec / 3600);
                                    const m = Math.floor((sec % 3600) / 60);
                                    return `${h}時${m}分後`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: '經過時間 (時:分)', font: { size: 10 } },
                            ticks: { 
                                maxTicksLimit: 6, 
                                font: { size: 10 },
                                callback: function(value) {
                                    const h = Math.floor(value / 3600);
                                    const m = Math.floor((value % 3600) / 60);
                                    return `${h}:${m.toString().padStart(2, '0')}`;
                                }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: { display: true, text: '數字', font: { size: 10 } }
                        }
                    }
                }
            });
        }

        function updateChartMainLine(pastElapsedMs, sessionElapsedMs, totalElapsedMs) {
            if (!chartInstance) return;

            let dataPoints = [];

            // 1. 強制加入原點 (0, 0)
            dataPoints.push({ x: 0, y: 0 });

            // 2. 加入「設定時」的狀態點 (X=pastElapsedMs, Y=startInput)
            // 這是從 0 到本次操作前的連線
            if (pastElapsedMs > 0) {
                dataPoints.push({ x: pastElapsedMs / 1000, y: state.start });
            }

            // 3. 加入本次 Session 的歷史點擊紀錄
            if (state.history.length > 0 && state.startTime) {
                const historyPoints = state.history.map(pt => ({
                    // 歷史點的 X = 過去時間 + (點擊時間 - Session開始時間)
                    x: (pastElapsedMs + (pt.t - state.startTime)) / 1000, 
                    y: pt.v
                })).filter(pt => pt.x >= (pastElapsedMs / 1000)); // 確保在 Start 點之後
                
                dataPoints = dataPoints.concat(historyPoints);
            }

            // 4. 連線到現在 (totalElapsedMs)
            // 只有當現在時間大於最後一個紀錄點時才加
            const currentX = totalElapsedMs / 1000;
            if (dataPoints.length === 0 || dataPoints[dataPoints.length-1].x < currentX) {
                 dataPoints.push({ x: currentX, y: state.current });
            }

            chartInstance.data.datasets[0].data = dataPoints;
            chartInstance.update('none');
        }

    </script>
</body>
</html>
