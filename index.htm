<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elon Mobile Tactical | 戰術分析</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <!-- Babel for JSX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <style>
        body {
            background-color: #000000; /* Pure Black for OLED mobile */
            color: #e2e8f0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        .stat-value {
            font-family: 'Courier New', Courier, monospace;
            font-weight: 700;
        }
        /* Mobile Optimizations */
        .mobile-card {
            background-color: #111;
            border: 1px solid #333;
            border-radius: 12px;
        }
        .safe-area-bottom {
            padding-bottom: env(safe-area-inset-bottom);
        }
        .glow-text {
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .stat-divider {
            border-right: 1px solid #333;
        }
        @keyframes flash-green {
            0% { color: white; }
            50% { color: #34d399; text-shadow: 0 0 15px #34d399; }
            100% { color: white; }
        }
        .animate-flash {
            animation: flash-green 1s ease-in-out;
        }
        /* Horizontal Scroll Hide */
        .hide-scroll::-webkit-scrollbar {
            display: none;
        }
        .hide-scroll {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        /* Gauge Slider */
        .gauge-track {
            background: #1f2937;
            height: 8px;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        .gauge-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
            /* Gradient for health bar effect */
            background: linear-gradient(90deg, #10b981 0%, #facc15 50%, #ef4444 100%);
        }
        /* Custom Scrollbar for Recent Posts */
        .custom-scroll::-webkit-scrollbar {
            width: 4px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #111; 
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #333; 
            border-radius: 2px;
        }
        .clickable-stat {
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
            padding: 0 4px;
        }
        .clickable-stat:active {
            background-color: rgba(255,255,255,0.1);
        }
        .clickable-stat:hover {
            color: #38bdf8; /* Sky-400 */
        }
        /* Heatmap Table */
        .heat-cell {
            font-family: monospace;
            font-size: 9px; /* Reduced font size */
            height: 14px;   /* Reduced height to remove scroll need */
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #222;
        }
        .heat-cell-inactive {
            background-color: #022c22; /* Dark Emerald (Modified) */
            color: #065f46;
            border-color: #064e3b;
        }
        .heat-cell-0 {
            background-color: #064e3b; /* Emerald 900 */
            color: #6ee7b7;
        }
        .heat-cell-active {
            background-color: #059669; /* Emerald 600 */
            color: white;
        }
        .heat-cell-hot {
            background-color: #34d399; /* Emerald 400 */
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        /* Chart Tooltip */
        .chart-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid #333;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 10px;
            color: white;
            z-index: 50;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            white-space: nowrap;
        }
        /* Terminal Log Style */
        .terminal-log {
            font-family: 'Courier New', Courier, monospace;
            font-size: 10px;
            line-height: 1.4;
            color: #34d399; /* Emerald 400 */
            text-shadow: 0 0 2px rgba(52, 211, 153, 0.5);
            pointer-events: none;
        }
        .terminal-cursor {
            display: inline-block;
            width: 6px;
            height: 12px;
            background-color: #34d399;
            animation: blink 1s step-end infinite;
            vertical-align: middle;
            margin-left: 2px;
        }
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, useRef } = React;

        // --- Inline Icons ---
        const IconBase = ({ path, className = "w-4 h-4" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>
        );
        const Activity = (props) => <IconBase {...props} path={<polyline points="22 12 18 12 15 21 9 3 6 12 2 12" />} />;
        const Clock = (props) => <IconBase {...props} path={<g><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></g>} />;
        const Terminal = (props) => <IconBase {...props} path={<g><polyline points="4 17 10 11 4 5" /><line x1="12" y1="19" x2="20" y2="19" /></g>} />;
        const RefreshCw = (props) => <IconBase {...props} path={<g><path d="M23 4v6h-6" /><path d="M1 20v-6h6" /><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15" /></g>} />;
        const ChevronDown = (props) => <IconBase {...props} path={<polyline points="6 9 12 15 18 9" />} />;
        const ChevronUp = (props) => <IconBase {...props} path={<polyline points="18 15 12 9 6 15" />} />;
        const ChevronLeft = (props) => <IconBase {...props} path={<polyline points="15 18 9 12 15 6" />} />;
        const ChevronRight = (props) => <IconBase {...props} path={<polyline points="9 18 15 12 9 6" />} />;
        const CheckCircle = (props) => <IconBase {...props} path={<g><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></g>} />;
        const FileText = (props) => <IconBase {...props} path={<g><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" /><polyline points="14 2 14 8 20 8" /><line x1="16" y1="13" x2="8" y2="13" /><line x1="16" y1="17" x2="8" y2="17" /><polyline points="10 9 9 9 8 9" /></g>} />;
        const BarChart2 = (props) => <IconBase {...props} path={<g><line x1="18" y1="20" x2="18" y2="10" /><line x1="12" y1="20" x2="12" y2="4" /><line x1="6" y1="20" x2="6" y2="14" /></g>} />;
        const Zap = (props) => <IconBase {...props} path={<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" />} />;
        const History = (props) => <IconBase {...props} path={<g><path d="M3 3v5h5"/><path d="M3.05 13A9 9 0 1 0 6 5.3L3 8"/><path d="M12 7v5l4 2"/></g>} />;
        const Trending = (props) => <IconBase {...props} path={<polyline points="23 6 13.5 15.5 8.5 10.5 1 18" />} />;
        const Calculator = (props) => <IconBase {...props} path={<g><rect x="4" y="2" width="16" height="20" rx="2" ry="2" /><line x1="8" y1="6" x2="16" y2="6" /><line x1="16" y1="14" x2="16" y2="18" /><path d="M16 10h.01" /><path d="M12 10h.01" /><path d="M8 10h.01" /><path d="M12 14h.01" /><path d="M8 14h.01" /><path d="M12 18h.01" /><path d="M8 18h.01" /></g>} />;
        const MessageSquare = (props) => <IconBase {...props} path={<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z" />} />;
        const Target = (props) => <IconBase {...props} path={<g><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></g>} />;
        const Forward = (props) => <IconBase {...props} path={<g><polyline points="13 17 18 12 13 7" /><polyline points="6 17 11 12 6 7" /></g>} />;
        const Moon = (props) => <IconBase {...props} path={<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />} />;
        const AlertOctagon = (props) => <IconBase {...props} path={<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2" />} />;
        const XCircle = (props) => <IconBase {...props} path={<g><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></g>} />;
        const Calendar = (props) => <IconBase {...props} path={<g><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></g>} />;
        const PieChart = (props) => <IconBase {...props} path={<g><path d="M21.21 15.89A10 10 0 1 1 8 2.83" /><path d="M22 12A10 10 0 0 0 12 2v10z" /></g>} />;
        const Send = (props) => <IconBase {...props} path={<g><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></g>} />;
        const Bell = (props) => <IconBase {...props} path={<g><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></g>} />;
        const Languages = (props) => <IconBase {...props} path={<g><path d="m5 8 6 6" /><path d="m4 14 6-6 2-3" /><path d="M2 5h12" /><path d="M7 2h1" /><path d="m22 22-5-10-5 10" /><path d="M14 18h6" /></g>} />;

        // --- Helper Functions (Moved outside App) ---
        const formatTimeET = (date) => date.toLocaleTimeString('en-US', { timeZone: 'America/New_York', hour12: false, hour: '2-digit', minute:'2-digit' });
        const formatDateET = (date) => date.toLocaleDateString('en-US', { timeZone: 'America/New_York', month: 'numeric', day: 'numeric' });
        const formatWeekdayET = (date) => date.toLocaleDateString('zh-TW', { timeZone: 'America/New_York', weekday: 'short' });
        
        const simpleTranslate = (text) => {
            if (!text) return "";
            let t = text;
            t = t.replace(/RT /g, "【轉推】");
            t = t.replace(/Space/gi, "太空");
            t = t.replace(/Mars/gi, "火星");
            t = t.replace(/crypto/gi, "加密貨幣");
            t = t.replace(/doge/gi, "狗狗幣");
            t = t.replace(/AI/g, "人工智慧");
            t = t.replace(/future/gi, "未來");
            return t;
        };

        // --- Components ---
        const SilenceProbBadge = ({ label, prob }) => {
            const p = parseInt(prob);
            let color = "text-gray-500";
            if (p > 70) color = "text-emerald-400 font-bold";
            else if (p > 40) color = "text-sky-400";
            return (
                <div className="flex flex-col items-center bg-gray-900/40 rounded p-1 border border-gray-800/50">
                    <span className="text-[9px] text-gray-500">{label}</span>
                    <span className={`text-xs font-mono ${color}`}>{prob}%</span>
                </div>
            );
        };

        const RateRow = ({ label, data, hours, remainingHours, currentTotal, totalPosts, onDetailClick }) => {
            if (!data) return null;
            const ratioNum = parseInt(data.ratio);
            const isHigh = ratioNum >= 100;
            const currentSpeed = (parseFloat(data.current) / hours).toFixed(1);
            const historyAvgSpeed = (parseFloat(data.avg) / hours);
            let speedColorClass = "text-gray-500"; 
            const speedDiff = parseFloat(currentSpeed) - historyAvgSpeed;
            if (speedDiff > 0) {
                if (parseFloat(currentSpeed) > historyAvgSpeed * 1.2) speedColorClass = "text-red-500 font-bold"; 
                else speedColorClass = "text-orange-400"; 
            } else if (speedDiff <= 0) { speedColorClass = "text-emerald-500"; }
            const additional = remainingHours > 0 ? (parseFloat(currentSpeed) * remainingHours) : 0;
            const totalProjected = (typeof currentTotal === 'number' ? currentTotal : 0) + additional;
            const baseTotal = typeof currentTotal === 'number' ? currentTotal : 0;

            return (
                <div className="py-3 border-b border-gray-800 last:border-0">
                    <div className="flex justify-between items-center mb-1">
                        <span className="text-sm text-gray-400 font-bold w-10">{label}</span>
                        <div className="flex items-center space-x-2">
                            <div className="text-[10px] text-gray-400 bg-slate-800/50 px-1 rounded flex items-center border border-slate-700" title="最新發文數 + (目前速度 * 剩餘時數)">
                                <span className="text-gray-500 mr-1.5 font-mono">{data.pos.toFixed(0)}%</span>
                                <Forward className="w-2.5 h-2.5 mr-0.5 text-blue-400" />
                                {totalProjected.toFixed(1)}
                            </div>
                            <div className={`text-[10px] font-mono bg-gray-900 px-1 rounded border border-gray-800 ${speedColorClass}`}>
                                {currentSpeed}/h
                            </div>
                            <span className="text-base font-bold text-white">{data.current} <span className="text-xs text-gray-500 font-normal">篇</span></span>
                        </div>
                    </div>
                    
                    <div className="flex justify-between items-end text-xs text-gray-500 mb-1 px-1">
                        <div className="flex flex-col items-center clickable-stat hover:text-emerald-400" onClick={() => onDetailClick({label, data, hours, type: 'min'})}>
                            <span>Min: {baseTotal + data.min} <span className="text-[9px] text-gray-600">({data.minFreq}%)</span></span>
                        </div>
                        <div className="flex flex-col items-center">
                            <span className={`text-[10px] font-bold ${isHigh ? 'text-red-500' : 'text-emerald-500'}`}>{isHigh ? '>' : '<'} {data.ratio}%</span>
                            <span className="text-gray-400 clickable-stat hover:text-sky-400" onClick={() => onDetailClick({label, data, hours, type: 'avg'})}>
                                Avg: {(baseTotal + parseFloat(data.avg)).toFixed(1)}
                            </span>
                        </div>
                        <div className="flex flex-col items-center clickable-stat hover:text-red-400" onClick={() => onDetailClick({label, data, hours, type: 'max'})}>
                            <span>Max: {baseTotal + data.max} <span className="text-[9px] text-gray-600">({data.maxFreq}%)</span></span>
                        </div>
                    </div>
                    <div className="gauge-track w-full mt-1">
                        <div className="gauge-fill" style={{width: `${data.pos}%`}}></div>
                    </div>
                </div>
            );
        };

        const HistoryCompareRow = ({ label, data }) => {
            if (!data) return null;
            const ratioNum = parseInt(data.ratio7d);
            const isHigh = ratioNum >= 100;
            return (
                <div className="py-2 border-b border-gray-800 last:border-0">
                    <div className="flex justify-between items-center mb-1 sticky left-0 bg-[#111]">
                        <span className="text-sm text-sky-400 font-bold w-12">{label}</span>
                        
                        <div className="flex flex-col items-center leading-none">
                            <span className="text-[10px] text-gray-400 font-mono">7D Avg: {data.avg7d}</span>
                            <span className={`text-[9px] font-bold mt-0.5 ${isHigh ? 'text-red-500' : 'text-emerald-500'}`}>
                                {isHigh ? '>' : '<'} {data.ratio7d}%
                            </span>
                        </div>

                        <span className="text-base text-white font-mono bg-gray-800 px-2 rounded w-10 text-center">{data.current}</span>
                    </div>
                    <div className="flex space-x-2 text-center pb-1 justify-between">
                        {data.history.map((val, idx) => (
                            <div key={idx} className="flex-1 flex flex-col items-center bg-gray-900/50 rounded py-1">
                                <span className="text-[8px] text-gray-500">-{idx+1}d</span>
                                <span className={`text-[10px] font-mono ${val > data.current ? 'text-emerald-400' : (val < data.current ? 'text-red-400' : 'text-gray-300')}`}>{val}</span>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const StatsDetailModal = ({ detail, onClose }) => {
            if (!detail) return null;
            const { label, data, hours } = detail;
            const formatTimeRange = (startTs, h) => {
                if (!startTs) return "N/A";
                const startDate = new Date(startTs);
                const endDate = new Date(startTs + h * 3600000);
                
                const fmt = (d) => d.toLocaleDateString('en-US', {
                    timeZone: 'America/New_York', month:'numeric', day:'numeric'
                }) + ' ' + d.toLocaleTimeString('en-US', {
                    timeZone: 'America/New_York', hour12:false, hour:'2-digit', minute:'2-digit'
                });

                return `${fmt(startDate)}~${fmt(endDate)}`;
            };

            return (
                <div className="modal-backdrop" onClick={onClose}>
                    <div className="bg-[#111] border border-gray-700 rounded-xl w-full max-w-sm overflow-hidden shadow-2xl animate-in zoom-in-95" onClick={e => e.stopPropagation()}>
                        <div className="bg-gray-900 px-4 py-3 border-b border-gray-800 flex justify-between items-center">
                            <div className="flex items-center space-x-2">
                                <BarChart2 className="w-5 h-5 text-sky-500" />
                                <h3 className="text-white font-bold text-lg">{label} 區間數據詳情</h3>
                            </div>
                            <button onClick={onClose} className="text-gray-400 hover:text-white"><XCircle className="w-6 h-6" /></button>
                        </div>
                        <div className="p-4 space-y-4 max-h-[70vh] overflow-y-auto">
                            <div className="text-xs text-gray-500 text-center mb-2">基於過去 90 天內，共 {data.samples.toLocaleString()} 個樣本</div>
                            <div className="bg-gray-800/30 rounded-lg p-3 border border-gray-700/50">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-emerald-500 font-bold flex items-center"><ChevronDown className="w-4 h-4 mr-1"/>歷史最低 (MIN)</span>
                                    <span className="text-2xl font-mono font-bold text-white">{data.min} <span className="text-xs text-gray-500">篇</span></span>
                                </div>
                                <div className="text-[11px] text-gray-400 space-y-1">
                                    <div className="flex justify-between"><span>發生時間:</span><span className="text-emerald-400 font-mono">{formatTimeRange(data.minTime, hours)}</span></div>
                                    <div className="flex justify-between"><span>出現頻率:</span><span className="text-white font-mono">{data.minFreq}%</span></div>
                                </div>
                            </div>
                            <div className="bg-gray-800/30 rounded-lg p-3 border border-gray-700/50">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-sky-500 font-bold flex items-center"><Activity className="w-4 h-4 mr-1"/>歷史平均 (AVG)</span>
                                    <span className="text-2xl font-mono font-bold text-white">{data.avg} <span className="text-xs text-gray-500">篇</span></span>
                                </div>
                            </div>
                            <div className="bg-gray-800/30 rounded-lg p-3 border border-gray-700/50">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-red-500 font-bold flex items-center"><ChevronUp className="w-4 h-4 mr-1"/>歷史最高 (MAX)</span>
                                    <span className="text-2xl font-mono font-bold text-white">{data.max} <span className="text-xs text-gray-500">篇</span></span>
                                </div>
                                <div className="text-[11px] text-gray-400 space-y-1">
                                    <div className="flex justify-between"><span>發生時間:</span><span className="text-red-400 font-mono">{formatTimeRange(data.maxTime, hours)}</span></div>
                                    <div className="flex justify-between"><span>出現頻率:</span><span className="text-white font-mono">{data.maxFreq}%</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        // --- Range Analysis Modal ---
        const RangeAnalysisModal = ({ data, onClose, currentCount, hoursToTarget, avgDailySilence }) => {
            if (!data) return null;
            const { range, prob } = data;
            const [start, end] = range.split('~').map(Number);
            const deltaStart = Math.max(0, start - currentCount);
            const deltaEnd = Math.max(0, end - currentCount);
            
            // Calculate active hours by deducting average rest time (prorated)
            const estRest = (hoursToTarget / 24) * avgDailySilence;
            const activeHours = Math.max(0.1, hoursToTarget - estRest);
            
            // Speed required during ACTIVE hours
            const activeRateMin = deltaStart / activeHours;
            const activeRateMax = deltaEnd / activeHours;
            
            let analysis = {
                bg: `【精準著陸】總時數 ${hoursToTarget.toFixed(1)}h，扣除預估休息 ${estRest.toFixed(1)}h，實戰工時僅 ${activeHours.toFixed(1)}h。`,
                up: `在實戰時間內，維持均速 ${activeRateMin.toFixed(2)} ~ ${activeRateMax.toFixed(2)} 篇/hr (醒著就要發)。`,
                down: `均速 > ${activeRateMax.toFixed(2)} (過快) 或 < ${activeRateMin.toFixed(2)} (過慢) 皆會偏離目標。`,
                type: "正常區間"
            };
            
            if (activeRateMax < 0.8) {
                 analysis = {
                    bg: `【靜默降落】目標極低 (${deltaEnd}篇)，實戰工時 ${activeHours.toFixed(1)}h 內幾乎不能發文。`,
                    up: "保持絕對靜默，或僅進行極低頻率的按讚/轉推 (每小時 < 0.5 篇)。",
                    down: `一旦清醒時連發 > 3 篇 (時速 > ${activeRateMax.toFixed(2)})，即會衝出區間 (Overshoot)。`,
                    type: "低頻 (Low)"
                };
            } else if (activeRateMin > 5.0) {
                 analysis = {
                    bg: `【極限衝刺】實戰工時 ${activeHours.toFixed(1)}h 內需狂發 ${deltaStart}+ 篇，難度極高。`,
                    up: `清醒時必須維持 "狂暴模式" (時速 > ${activeRateMin.toFixed(1)})，不能有任何額外休息。`,
                    down: `若睡眠時間超過預期的 ${estRest.toFixed(1)}h，或清醒時分心，將無法達成 (Undershoot)。`,
                    type: "激進 (Burst)"
                };
            }

            return (
                <div className="modal-backdrop" onClick={onClose}>
                     <div className="bg-[#111] border border-gray-700 rounded-xl w-full max-w-sm p-4 shadow-2xl" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-start mb-3">
                            <div>
                                <h3 className="text-white font-bold text-lg">區間分析: {range}</h3>
                                <div className="text-xs text-gray-500">預測機率: <span className="text-emerald-400 font-bold">{prob}%</span></div>
                            </div>
                            <button onClick={onClose} className="text-gray-400"><XCircle className="w-5 h-5"/></button>
                        </div>
                        <div className="space-y-3">
                            <div className="bg-gray-800/30 p-2 rounded border border-gray-700">
                                <div className="text-[10px] text-sky-400 font-bold uppercase mb-1">情境背景 ({analysis.type})</div>
                                <div className="text-xs text-gray-300">{analysis.bg}</div>
                            </div>
                            <div className="grid grid-cols-2 gap-2">
                                <div className="bg-emerald-900/20 p-2 rounded border border-emerald-800/50">
                                    <div className="text-[10px] text-emerald-400 font-bold uppercase mb-1">機率增加因素</div>
                                    <div className="text-[10px] text-gray-300 leading-relaxed">{analysis.up}</div>
                                </div>
                                 <div className="bg-red-900/20 p-2 rounded border border-red-800/50">
                                    <div className="text-[10px] text-red-400 font-bold uppercase mb-1">機率減少因素</div>
                                    <div className="text-[10px] text-gray-300 leading-relaxed">{analysis.down}</div>
                                </div>
                            </div>
                            <div className="text-[9px] text-gray-500 text-center pt-2">
                                需增加 {deltaStart}~{deltaEnd} 篇 | 實戰均速 {activeRateMin.toFixed(2)}~{activeRateMax.toFixed(2)}/h
                            </div>
                        </div>
                     </div>
                </div>
            )
        };

        const RangeProbabilities = ({ posts, currentCount, hoursToTarget, setStatsRef }) => {
            const [probs, setProbs] = useState([]);
            const [selectedRange, setSelectedRange] = useState(null);

            // Calculate Avg Daily Silence (>3h gaps)
            const avgDailySilence = useMemo(() => {
                if (posts.length < 2) return 0;
                const sorted = [...posts].sort((a,b) => new Date(a.createdAt) - new Date(b.createdAt));
                let totalSilenceHours = 0;
                const start = new Date(sorted[0].createdAt);
                const end = new Date(sorted[sorted.length-1].createdAt);
                // Total days covered by history (approx)
                const days = Math.max(1, (end - start) / (1000 * 60 * 60 * 24));
                
                for(let i=0; i<sorted.length-1; i++) {
                    const diff = (new Date(sorted[i+1].createdAt) - new Date(sorted[i].createdAt)) / 3600000;
                    if(diff > 3) totalSilenceHours += diff;
                }
                return totalSilenceHours / days;
            }, [posts]);

            useEffect(() => {
                if (!posts.length || hoursToTarget <= 0) {
                    if (probs.length > 0) setProbs([]);
                    return;
                }
                
                const timer = setTimeout(() => {
                    const timestamps = posts.map(p => new Date(p.createdAt).getTime()).sort((a,b)=>a-b);
                    const windowMs = hoursToTarget * 3600 * 1000;
                    
                    const now = Date.now();
                    const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;
                    const cutoffTime = now - thirtyDaysMs;

                    const n = timestamps.length;
                    
                    if (timestamps[n-1] - timestamps[0] < windowMs) return;

                    // Sliding window
                    let left = 0;
                    let right = 0;
                    
                    const samplesRecent = [];
                    const samplesOld = [];

                    for (let t = timestamps[0]; t <= timestamps[n-1] - windowMs; t += 3600000) {
                        while (left < n && timestamps[left] < t) left++;
                        while (right < n && timestamps[right] < t + windowMs) right++;
                        const count = right - left;
                        
                        if (t >= cutoffTime) {
                            samplesRecent.push(count);
                        } else {
                            samplesOld.push(count);
                        }
                    }
                    
                    const calcBucketProbs = (samples) => {
                        const total = samples.length;
                        if (total === 0) return {};
                        const counts = {};
                        samples.forEach(delta => {
                            const finalVal = (currentCount || 0) + delta;
                            const bucketIdx = Math.floor(finalVal / 20);
                            counts[bucketIdx] = (counts[bucketIdx] || 0) + 1;
                        });
                        const probs = {};
                        for(let k in counts) {
                            probs[k] = counts[k] / total;
                        }
                        return probs;
                    };

                    const probsRecent = calcBucketProbs(samplesRecent);
                    const probsOld = calcBucketProbs(samplesOld);
                    
                    const results = [];
                    const maxBucketIdx = Math.floor(739 / 20); 
                    const currentBucketIdx = Math.floor((currentCount || 0) / 20);

                    let webhookStr = "";

                    for (let i = currentBucketIdx; i <= maxBucketIdx; i++) {
                        const start = i * 20;
                        const end = start + 19;
                        
                        if (end < currentCount) continue;
                        
                        let prob = 0;
                        const pR = probsRecent[i] || 0;
                        const pO = probsOld[i] || 0;

                        if (samplesRecent.length > 0 && samplesOld.length > 0) {
                            prob = (pR * 0.7) + (pO * 0.3);
                        } else if (samplesRecent.length > 0) {
                            prob = pR;
                        } else {
                            prob = pO;
                        }
                        
                        const probPercent = prob * 100;
                        
                        if (probPercent >= 0.1) {
                            const pStr = probPercent.toFixed(1);
                            results.push({ range: `${start}~${end}`, prob: pStr });
                            webhookStr += `${start}~${end}:${pStr}% `;
                        }
                    }
                    setProbs(results);
                    
                    // Update ref for webhook
                    setStatsRef(prev => ({ ...prev, rangeProbs: webhookStr }));

                }, 500); 

                return () => clearTimeout(timer);
            }, [posts, currentCount, hoursToTarget, setStatsRef]);

            if (hoursToTarget <= 0) return null;

            return (
                <div className="mobile-card p-4 mt-4">
                    <h3 className="text-xs text-gray-500 uppercase mb-2 flex items-center">
                        <PieChart className="w-3 h-3 mr-1" /> 區間機率預測 (Range Prob)
                    </h3>
                    {probs.length === 0 ? (
                        <div className="text-center py-4 text-[10px] text-gray-500 animate-pulse">
                            正在模擬 {hoursToTarget.toFixed(1)}h 後的落點...
                        </div>
                    ) : (
                        <div>
                             <div className="grid grid-cols-4 gap-2">
                                 {probs.map((p, idx) => (
                                     <div 
                                        key={idx} 
                                        onClick={() => setSelectedRange(p)}
                                        className="bg-gray-800/40 rounded p-2 text-center border border-gray-700/50 cursor-pointer hover:bg-gray-700/50 transition-colors"
                                     >
                                         <div className="text-[10px] text-gray-400">{p.range}</div>
                                         <div className={`text-sm font-bold font-mono ${parseFloat(p.prob) > 20 ? 'text-emerald-400' : 'text-white'}`}>{p.prob}%</div>
                                     </div>
                                 ))}
                             </div>
                        </div>
                    )}
                    <div className="text-[9px] text-gray-600 mt-2 text-right">
                        近期權重 70% | 遠期權重 30% | 過濾 &lt;0.1%
                    </div>
                    
                    {selectedRange && (
                        <RangeAnalysisModal 
                            data={selectedRange} 
                            currentCount={currentCount} 
                            hoursToTarget={hoursToTarget} 
                            avgDailySilence={avgDailySilence}
                            onClose={() => setSelectedRange(null)} 
                        />
                    )}
                </div>
            );
        };


        // --- Weekly Heatmap Component ---
        const WeeklyHeatmap = ({ posts, liveCount, setStatsRef }) => {
            const [selectedDate, setSelectedDate] = useState(() => {
                const saved = localStorage.getItem('elon_tactical_heatmap_date');
                return saved ? new Date(saved) : new Date();
            });
            const [viewMonth, setViewMonth] = useState(() => {
                const saved = localStorage.getItem('elon_tactical_heatmap_date');
                return saved ? new Date(saved) : new Date();
            });

            const handleSelectDate = (date) => {
                setSelectedDate(date);
                localStorage.setItem('elon_tactical_heatmap_date', date.toISOString());
            };

            const getKeyDates = (date) => {
                const year = date.getFullYear();
                const month = date.getMonth();
                const dates = [];
                const d = new Date(year, month, 1);
                while (d.getMonth() === month) {
                    const day = d.getDay();
                    if (day === 2 || day === 5) { 
                        dates.push(new Date(d));
                    }
                    d.setDate(d.getDate() + 1);
                }
                return dates;
            };

            const keyDates = useMemo(() => getKeyDates(viewMonth), [viewMonth]);
            const isFutureDate = (d) => {
                const check = new Date(d);
                const now = new Date();
                check.setHours(0,0,0,0);
                now.setHours(0,0,0,0);
                return check > now;
            };
            const availableKeyDates = useMemo(() => keyDates.filter(d => !isFutureDate(d)), [keyDates]);

            useEffect(() => {
                if (availableKeyDates.length > 0) {
                     const isSelectedInList = availableKeyDates.some(d => d.toDateString() === selectedDate.toDateString());
                     
                     if (!isSelectedInList) {
                         setSelectedDate(availableKeyDates[availableKeyDates.length - 1]);
                     }
                }
            }, [viewMonth, availableKeyDates]); 

            const changeMonth = (delta) => {
                const newDate = new Date(viewMonth);
                newDate.setMonth(newDate.getMonth() + delta);
                setViewMonth(newDate);
            };

            const activeWindow = useMemo(() => {
                if (!selectedDate) return null;
                const year = selectedDate.getFullYear();
                const month = selectedDate.getMonth();
                const date = selectedDate.getDate();
                const etOffset = 5; 
                const gridStartTimeMs = Date.UTC(year, month, date, etOffset, 0, 0); 
                const activeStartMs = gridStartTimeMs + (12 * 3600000); 
                const activeEndMs = activeStartMs + (7 * 24 * 3600000); 
                return { gridStartTimeMs, activeStartMs, activeEndMs };
            }, [selectedDate]);

            // Enhanced Stats Calculation: Min, Avg, Max
            const getHistoricalStats = (targetDate, currentVal, dayIndex) => {
                if (!targetDate || posts.length === 0) return { min:0, avg:0, max:0, isToday: false, isFuture: false };

                const nowET = new Date(new Date().toLocaleString("en-US", {timeZone: "America/New_York"}));
                const targetET = new Date(targetDate.toLocaleString("en-US", {timeZone: "America/New_York"}));
                targetET.setHours(0,0,0,0);
                const todayET = new Date(nowET);
                todayET.setHours(0,0,0,0);

                const isToday = targetET.getTime() === todayET.getTime();
                const isFuture = targetET.getTime() > todayET.getTime();
                const currentHourET = nowET.getHours();
                
                let historicalTotals = [];
                let historicalRemainings = [];
                
                for(let i=1; i<=12; i++) {
                    const pastDate = new Date(targetDate);
                    pastDate.setDate(pastDate.getDate() - (i * 7));
                    
                    const startMs = Date.UTC(pastDate.getFullYear(), pastDate.getMonth(), pastDate.getDate(), 5, 0, 0); 
                    const endMs = startMs + (24 * 3600000);
                    const cutoffMs = startMs + (currentHourET * 3600000);

                    let validStart = startMs;
                    let validEnd = endMs;
                    if (dayIndex === 0) validStart = startMs + (12 * 3600000); 
                    else if (dayIndex === 7) validEnd = startMs + (12 * 3600000); 

                    const dayPosts = posts.filter(p => {
                        const t = new Date(p.createdAt).getTime();
                        return t >= validStart && t < validEnd;
                    });
                    
                    const soFarPosts = dayPosts.filter(p => {
                         const t = new Date(p.createdAt).getTime();
                         return t < cutoffMs; 
                    });

                    const oldestPost = posts[posts.length-1];
                    if (oldestPost && pastDate > new Date(oldestPost.createdAt)) {
                        historicalTotals.push(dayPosts.length);
                        historicalRemainings.push(dayPosts.length - soFarPosts.length);
                    }
                }
                
                const calcStats = (arr) => {
                    if (arr.length === 0) return { min:0, avg:0, max:0 };
                    const sorted = [...arr].sort((a,b)=>a-b);
                    const sum = sorted.reduce((a,b)=>a+b,0);
                    return {
                        min: sorted[0],
                        max: sorted[sorted.length-1],
                        avg: sum / sorted.length
                    };
                }

                const totalStats = calcStats(historicalTotals);
                const remainStats = calcStats(historicalRemainings);

                let res = { min: 0, avg: 0, max: 0, isToday, isFuture };

                if (isToday) {
                    res.min = currentVal + remainStats.min;
                    res.avg = currentVal + remainStats.avg;
                    res.max = currentVal + remainStats.max;
                } else if (isFuture) {
                    res.min = totalStats.min;
                    res.avg = totalStats.avg;
                    res.max = totalStats.max;
                }

                return res;
            };

            const gridData = useMemo(() => {
                if (!activeWindow) return null;
                const { gridStartTimeMs, activeStartMs, activeEndMs } = activeWindow;
                const oneDay = 24 * 60 * 60 * 1000;
                const grid = Array(24).fill(0).map(() => Array(8).fill(0));
                
                posts.forEach(p => {
                    const t = new Date(p.createdAt).getTime();
                    const diffMs = t - gridStartTimeMs;
                    if (diffMs >= 0) {
                        const diffHours = Math.floor(diffMs / 3600000);
                        const dayIdx = Math.floor(diffHours / 24);
                        const hourIdx = diffHours % 24;
                        if (dayIdx >= 0 && dayIdx < 8) {
                            grid[hourIdx][dayIdx]++;
                        }
                    }
                });
                const headers = [];
                for(let i=0; i<8; i++) {
                    headers.push(new Date(gridStartTimeMs + i * oneDay));
                }
                return { grid, headers, activeStartMs, activeEndMs };
            }, [activeWindow, posts]);

            const getCellClass = (val, cellTimeMs, activeStartMs, activeEndMs) => {
                if (cellTimeMs < activeStartMs || cellTimeMs >= activeEndMs) return "bg-[#111] border border-[#222] text-[#333]";
                if (val === 0) return "heat-cell-inactive text-gray-700";
                if (val >= 10) return "heat-cell-hot";
                return "bg-emerald-800 text-emerald-100";
            };

            const summaryData = useMemo(() => {
                if (!gridData) return { totalActual: 0, proj: {min:0, avg:0, max:0} };
                
                let totalActual = 0;
                let projMin = 0, projAvg = 0, projMax = 0;

                gridData.headers.forEach((d, dIdx) => {
                    const isFuture = isFutureDate(d);
                    const colSum = gridData.grid.reduce((acc, row, hIdx) => {
                         const cellTimeMs = gridData.headers[dIdx].getTime() + (hIdx * 3600000);
                         if (cellTimeMs >= gridData.activeStartMs && cellTimeMs < gridData.activeEndMs) return acc + row[dIdx];
                         return acc;
                    }, 0);

                    const validActual = isFuture ? 0 : colSum;
                    totalActual += validActual;

                    const stats = getHistoricalStats(d, validActual, dIdx);
                    
                    if (stats.isFuture || stats.isToday) {
                        projMin += stats.min;
                        projAvg += stats.avg;
                        projMax += stats.max;
                    } else {
                        projMin += validActual;
                        projAvg += validActual;
                        projMax += validActual;
                    }
                });
                
                const result = { totalActual, proj: {min: projMin, avg: projAvg, max: projMax} };

                // Update ref for webhook
                setStatsRef(prev => ({
                    ...prev,
                    heatmapMin: projMin.toFixed(0),
                    heatmapAvg: projAvg.toFixed(0),
                    heatmapMax: projMax.toFixed(0)
                }));

                return result;
            }, [gridData, posts, setStatsRef]); 

            const tuesdayDates = availableKeyDates.filter(d => d.getDay() === 2);
            const fridayDates = availableKeyDates.filter(d => d.getDay() === 5);

            return (
                <div className="mobile-card p-4 mb-4">
                    <div className="flex justify-between items-center mb-4">
                        <div className="flex items-center space-x-2">
                            <Calendar className="w-4 h-4 text-sky-500" />
                            <h3 className="text-sm font-bold text-gray-200">週期熱力圖 (12:00 ET Base)</h3>
                        </div>
                        <div className="flex items-center bg-gray-900 rounded-lg p-1 border border-gray-700">
                            <button onClick={() => changeMonth(-1)} className="p-1 hover:text-white text-gray-500"><ChevronLeft className="w-4 h-4"/></button>
                            <span className="mx-2 text-xs font-mono font-bold w-16 text-center">{viewMonth.getFullYear()}/{viewMonth.getMonth()+1}</span>
                            <button onClick={() => changeMonth(1)} className="p-1 hover:text-white text-gray-500"><ChevronRight className="w-4 h-4"/></button>
                        </div>
                    </div>
                    
                    <div className="flex flex-col gap-2 mb-4 bg-gray-900/30 p-2 rounded-lg border border-gray-800">
                        <div className="flex items-center space-x-2">
                            <span className="text-[9px] text-gray-500 w-6">Tue</span>
                            <div className="flex flex-wrap gap-2">
                                {tuesdayDates.map(d => (
                                    <button 
                                        key={d.toISOString()} 
                                        onClick={() => handleSelectDate(d)} 
                                        className={`text-[10px] font-mono px-3 py-1 rounded border transition-all ${selectedDate.getDate() === d.getDate() && selectedDate.getMonth() === d.getMonth() ? "bg-sky-600 text-white border-sky-400 font-bold shadow-lg" : "bg-gray-800 text-gray-400 border-gray-700"}`}
                                    >
                                        {d.getDate()}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div className="flex items-center space-x-2 border-t border-gray-800/50 pt-2">
                            <span className="text-[9px] text-gray-500 w-6">Fri</span>
                            <div className="flex flex-wrap gap-2">
                                {fridayDates.map(d => (
                                    <button 
                                        key={d.toISOString()} 
                                        onClick={() => handleSelectDate(d)} 
                                        className={`text-[10px] font-mono px-3 py-1 rounded border transition-all ${selectedDate.getDate() === d.getDate() && selectedDate.getMonth() === d.getMonth() ? "bg-purple-600 text-white border-purple-400 font-bold shadow-lg" : "bg-gray-800 text-gray-400 border-gray-700"}`}
                                    >
                                        {d.getDate()}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>

                    {gridData && (
                        <div className="overflow-x-auto">
                             <div className="min-w-[300px]">
                                <div className="flex ml-8 mb-1">
                                    {gridData.headers.map((d, i) => (
                                        <div key={i} className="flex-1 text-center text-[9px] text-gray-400 leading-tight whitespace-pre">
                                            {d.toLocaleDateString('zh-TW', {timeZone:'America/New_York', weekday:'short', day:'numeric'}).replace(/(\d+)/, '\n$1')}
                                        </div>
                                    ))}
                                </div>
                                {gridData.grid.map((row, hIdx) => (
                                    <div key={hIdx} className="flex h-[15px] mb-[1px]">
                                        <div className="w-8 text-[9px] text-gray-600 text-right pr-2 leading-[15px] font-mono flex-shrink-0">{hIdx.toString().padStart(2, '0')}:00</div>
                                        {row.map((val, dIdx) => {
                                            const cellTimeMs = gridData.headers[dIdx].getTime() + (hIdx * 3600000);
                                            const isFuture = isFutureDate(gridData.headers[dIdx]);
                                            const displayVal = isFuture ? 0 : val;
                                            const isActive = cellTimeMs >= gridData.activeStartMs && cellTimeMs < gridData.activeEndMs;
                                            return (
                                                <div key={dIdx} className={`flex-1 mx-[1px] rounded-sm heat-cell ${getCellClass(displayVal, cellTimeMs, gridData.activeStartMs, gridData.activeEndMs)}`}>
                                                    {displayVal > 0 && isActive ? displayVal : ''}
                                                </div>
                                            );
                                        })}
                                    </div>
                                ))}
                                <div className="flex h-6 mt-1 border-t border-gray-800 pt-1">
                                     <div className="w-8 text-[9px] text-sky-500 text-right pr-2 leading-[20px] font-bold">Total</div>
                                     {gridData.grid[0].map((_, dIdx) => {
                                         const isFuture = isFutureDate(gridData.headers[dIdx]);
                                         const colSum = isFuture ? 0 : gridData.grid.reduce((acc, row, hIdx) => {
                                             const cellTimeMs = gridData.headers[dIdx].getTime() + (hIdx * 3600000);
                                             if (cellTimeMs >= gridData.activeStartMs && cellTimeMs < gridData.activeEndMs) return acc + row[dIdx];
                                             return acc;
                                         }, 0);
                                         return <div key={dIdx} className="flex-1 text-center text-[9px] text-sky-400 font-mono font-bold leading-[20px]">{isFuture ? '-' : colSum}</div>
                                     })}
                                </div>
                                {/* Proj. Row with Min/Avg/Max */}
                                <div className="flex mt-1 pb-1">
                                     <div className="w-8 text-[9px] text-gray-500 text-right pr-2 leading-[14px]">Proj.</div>
                                     {gridData.grid[0].map((_, dIdx) => {
                                         const targetDate = gridData.headers[dIdx];
                                         const isFuture = isFutureDate(targetDate);
                                         const colSum = isFuture ? 0 : gridData.grid.reduce((acc, row, hIdx) => {
                                             const cellTimeMs = gridData.headers[dIdx].getTime() + (hIdx * 3600000);
                                             if (cellTimeMs >= gridData.activeStartMs && cellTimeMs < gridData.activeEndMs) return acc + row[dIdx];
                                             return acc;
                                         }, 0);
                                         const stats = getHistoricalStats(targetDate, colSum, dIdx);
                                         
                                         if (!stats.isToday && !stats.isFuture) return <div key={dIdx} className="flex-1 text-center text-[9px] text-gray-600">-</div>;

                                         return (
                                             <div key={dIdx} className="flex-1 flex flex-col items-center justify-center leading-none text-[8px] font-mono">
                                                 <span className="text-red-400">{stats.max.toFixed(0)}</span>
                                                 <span className="text-emerald-400">{stats.avg.toFixed(0)}</span>
                                                 <span className="text-gray-500">{stats.min.toFixed(0)}</span>
                                             </div>
                                         )
                                     })}
                                </div>
                                <div className="flex justify-between items-center mt-2 pt-2 border-t border-gray-800/50 px-1">
                                    <div className="flex items-center space-x-2">
                                        <div className="text-[9px] text-gray-500 text-right">總預估值 (Total Proj) <br/><span className="text-[8px]">(Min/Avg/Max)</span></div>
                                        <div className="flex flex-col text-right font-mono font-bold text-xs">
                                            <span className="text-red-400">{summaryData.proj.max.toFixed(0)}</span>
                                            <span className="text-emerald-400">{summaryData.proj.avg.toFixed(0)}</span>
                                            <span className="text-gray-500">{summaryData.proj.min.toFixed(0)}</span>
                                        </div>
                                    </div>
                                    <div className="flex flex-col items-end">
                                        <span className="text-[9px] text-gray-500">目前總數 (Actual)</span>
                                        <span className="text-sm font-mono font-bold text-sky-400">{summaryData.totalActual}</span>
                                    </div>
                                </div>
                             </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- New Historical Range Stats Component ---
        const HistoricalRangeStats = ({ posts, currentActiveWindow, activeCycleType }) => {
            const [stats, setStats] = useState([]);

            useEffect(() => {
                if (!posts.length) return;
                
                // Known Cycle Starts (Date Strings)
                const knownTueCycles = ["2024/11/04", "2024/11/11", "2024/11/18", "2024/11/25", "2024/12/02", "2024/12/09", "2024/12/16"];
                const knownThuCycles = ["2024/10/31", "2024/11/07", "2024/11/14", "2024/11/21", "2024/11/28", "2024/12/05", "2024/12/12", "2024/12/19"];

                const targetCycles = activeCycleType === 'thu' ? knownThuCycles : knownTueCycles;
                
                const cycleCounts = [];
                
                targetCycles.forEach(dateStr => {
                    const parts = dateStr.split('/');
                    const y = parseInt(parts[0]);
                    const m = parseInt(parts[1]) - 1;
                    const d = parseInt(parts[2]);
                    
                    // Construct 12:00 ET (UTC-5) -> 17:00 UTC
                    const startMs = Date.UTC(y, m, d, 17, 0, 0); 
                    const endMs = startMs + (7 * 24 * 3600 * 1000); // 7 Days
                    
                    const count = posts.filter(p => {
                        const t = new Date(p.createdAt).getTime();
                        return t >= startMs && t < endMs;
                    }).length;
                    
                    cycleCounts.push(count);
                });
                
                const totalCycles = cycleCounts.length;
                if (totalCycles === 0) return;

                const bucketCounts = {};
                cycleCounts.forEach(val => {
                    const bucketIdx = Math.floor(val / 20);
                    bucketCounts[bucketIdx] = (bucketCounts[bucketIdx] || 0) + 1;
                });
                
                const results = [];
                const maxBucketIdx = Math.max(...Object.keys(bucketCounts).map(Number), 0); 
                
                for(let i=0; i<=maxBucketIdx; i++) {
                    if (bucketCounts[i]) {
                        const count = bucketCounts[i];
                        const prob = (count / totalCycles) * 100;
                        results.push({
                            range: `${i*20}~${i*20+19}`,
                            count: count,
                            prob: prob.toFixed(1)
                        });
                    }
                }
                
                results.sort((a,b) => {
                    const startA = parseInt(a.range.split('~')[0]);
                    const startB = parseInt(b.range.split('~')[0]);
                    return startA - startB;
                });

                setStats({ totalCycles, data: results, type: activeCycleType === 'thu' ? '週四 (Thu)' : '週二 (Tue)' });

            }, [posts, activeCycleType]);

            if (!stats || !stats.data || stats.data.length === 0) return null;

            return (
                <div className="mobile-card p-4 mt-4">
                    <h3 className="text-xs text-gray-500 uppercase mb-2 flex items-center justify-between">
                        <div className="flex items-center"><History className="w-3 h-3 mr-1" /> 歷史週期分佈 ({stats.type})</div>
                        <div className="text-[9px] text-gray-600">樣本: {stats.totalCycles} 週</div>
                    </h3>
                    <div className="grid grid-cols-4 gap-2">
                        {stats.data.map((item, idx) => (
                            <div key={idx} className="bg-gray-900/50 rounded p-2 text-center border border-gray-800">
                                <div className="text-[10px] text-gray-400">{item.range}</div>
                                <div className="flex items-baseline justify-center space-x-1">
                                    <span className="text-sm font-bold text-white">{item.count}</span>
                                    <span className="text-[9px] text-gray-500 font-mono">({item.prob}%)</span>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const App = () => {
            // ... (App state and other hooks) ...
            // --- State ---
            const [posts, setPosts] = useState([]);
            const [userInfo, setUserInfo] = useState(null);
            const [loading, setLoading] = useState(false);
            const [lastUpdated, setLastUpdated] = useState(null); 
            const [currentTime, setCurrentTime] = useState(new Date());
            const [dataSource, setDataSource] = useState("init"); 
            const [showControls, setShowControls] = useState(false); 
            const [errorMsg, setErrorMsg] = useState(null);
            const [isNewPost, setIsNewPost] = useState(false);
            const [selectedStatDetail, setSelectedStatDetail] = useState(null);
            const [initLogs, setInitLogs] = useState([]); // Log state
            const [visiblePostsCount, setVisiblePostsCount] = useState(30);
            
            // Google Translation State
            const [googleApiKey, setGoogleApiKey] = useState(() => {
                return localStorage.getItem('elon_tactical_google_key') || "";
            });
            const [googleTranslations, setGoogleTranslations] = useState({}); // Map: { postId: translatedText }

            // Webhook State
            const [webhookUrl, setWebhookUrl] = useState(() => {
                return localStorage.getItem('elon_tactical_webhook') || "https://script.google.com/macros/s/AKfycbwJDJIgYP-XB70DpSiAYcVprTo-C5562Lvdj25M4KkxKpMt9OEq417a8ctUUBP-TZkw/exec";
            });
            
            // Stats Ref to hold latest calculated values for webhook
            const [statsRef, setStatsRef] = useState({
                predictionAvg: 0,
                predictionConf: 0,
                velocity12H: 0,
                velocity24h: 0, // NEW: For notification
                projectedCurrent: 0,
                projected7Day: 0,
                heatmapMin: 0,
                heatmapAvg: 0,
                heatmapMax: 0,
                rangeProbs: ""
            });

            // Update localStorage when URL changes
            useEffect(() => {
                localStorage.setItem('elon_tactical_webhook', webhookUrl);
            }, [webhookUrl]);

            // Update localStorage when API Key changes
            useEffect(() => {
                localStorage.setItem('elon_tactical_google_key', googleApiKey);
            }, [googleApiKey]);

            // Audio & Notification Logic
            const playAlarm = useCallback(() => {
                try {
                    const audio = new Audio('Alarm02.wav');
                    audio.play().catch(() => { 
                        // Ignore auto-play policy errors or file not found
                    });
                } catch (e) {
                    // Ignore construction errors
                }
            }, []);

            const requestNotificationPermission = useCallback(() => {
                if (!("Notification" in window)) return;
                if (Notification.permission !== "granted") {
                    Notification.requestPermission();
                }
            }, []);

            const sendSystemNotification = useCallback((currentCount, rate24h) => {
                if (!("Notification" in window)) return;
                if (Notification.permission === "granted") {
                    try {
                        const title = "Elon Mobile Tactical";
                        const body = `發文數更新:目前發文數 ${currentCount}, 目前1天平均速率為: ${rate24h}`;
                        new Notification(title, { body, icon: 'https://abs.twimg.com/sticky/default_profile_images/default_profile_400x400.png' });
                    } catch (e) {
                        console.error("Notification error", e);
                    }
                }
            }, []);

            // Webhook sender function
            const sendWebhook = async (message) => {
                if (!webhookUrl) return;
                
                addLog(`發送 Webhook: ${message}`);
                
                let requestOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                };

                let fetchUrl = webhookUrl;

                if (webhookUrl.includes("discord.com")) {
                    requestOptions.body = JSON.stringify({ content: message });
                } else if (webhookUrl.includes("script.google.com")) {
                    requestOptions.mode = 'no-cors';
                    requestOptions.headers = { 'Content-Type': 'text/plain' }; 
                    requestOptions.body = JSON.stringify({ message: message });
                } else {
                    requestOptions.body = JSON.stringify({ message: message, text: message });
                }

                try {
                    await fetch(fetchUrl, requestOptions);
                    addLog("Webhook 發送成功");
                } catch (error) {
                    addLog(`Webhook 錯誤: ${error.message}`);
                }
            };
            
            const [specialCount, setSpecialCount] = useState(null);
            const [specialLastFetchTime, setSpecialLastFetchTime] = useState(null);
            const [loadingSpecial, setLoadingSpecial] = useState(false); 
            const [isOffline, setIsOffline] = useState(false); 
            
            // --- Fix for Request Overlap ---
            const prevSpecialCountRef = useRef(null);
            const isFetchingSpecialRef = useRef(false); // New Ref to lock fetch

            const [predictInput, setPredictInput] = useState(''); 
            const [parsedHours, setParsedHours] = useState(null);
            const [prediction, setPrediction] = useState(null);
            
            // Helper for logging
            const addLog = (msg) => {
                setInitLogs(prev => {
                    const newLogs = [...prev, `[${new Date().toLocaleTimeString('en-US', {hour12: false})}] ${msg}`];
                    return newLogs.slice(-15); // Keep last 15 lines
                });
            };

            // NEW: Google Translation Logic
            const translatePostsBatch = useCallback(async (postsToTranslate) => {
                if (!googleApiKey || postsToTranslate.length === 0) return;
                
                // Filter out posts that are already translated or empty
                const targets = postsToTranslate.filter(p => !googleTranslations[p.id] && p.content && p.content.trim() !== "");
                if (targets.length === 0) return;

                addLog(`正在翻譯 ${targets.length} 篇貼文...`);

                try {
                    const url = `https://translation.googleapis.com/language/translate/v2?key=${googleApiKey}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            q: targets.map(p => p.content),
                            target: 'zh-TW',
                            format: 'text'
                        })
                    });

                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.error?.message || "Translation API Error");
                    }

                    const data = await response.json();
                    const newTranslations = {};
                    data.data.translations.forEach((t, i) => {
                        newTranslations[targets[i].id] = t.translatedText;
                    });

                    setGoogleTranslations(prev => ({...prev, ...newTranslations}));
                    addLog("Google 翻譯完成！");

                } catch (error) {
                    addLog(`翻譯失敗: ${error.message}`);
                    console.error("Google Translate Error:", error);
                }
            }, [googleApiKey, googleTranslations]);

            const targetDate = useMemo(() => {
                const now = new Date(); 
                let year = now.getFullYear();
                if (now.getMonth() === 0 && now.getDate() > 2) year++; 
                const target = new Date(Date.UTC(year, 0, 2, 17, 0, 0)); 
                return target;
            }, []);

            const [hoursToTarget, setHoursToTarget] = useState(0);

            // Updated Active Window Detection for Historical Stats
            const activeCycleType = useMemo(() => {
                const now = new Date(new Date().toLocaleString("en-US", {timeZone: "America/New_York"}));
                const currentDay = now.getDay(); // 0-6 Sun-Sat
                const currentHour = now.getHours();

                // Logic: Find most recent Tue 12:00 and most recent Thu 12:00
                const getRecentDay = (dayIndex) => {
                    const d = new Date(now);
                    d.setDate(d.getDate() - ((d.getDay() + 7 - dayIndex) % 7));
                    if (d.getDay() === dayIndex && d.getHours() < 12) {
                         d.setDate(d.getDate() - 7);
                    }
                    d.setHours(12, 0, 0, 0);
                    return d;
                };

                const lastTue = getRecentDay(2); // Tue
                const lastThu = getRecentDay(4); // Thu
                
                return lastThu > lastTue ? 'thu' : 'tue';
            }, []);

            const currentActiveWindow = useMemo(() => {
                const t = new Date();
                const dayOffset = activeCycleType === 'thu' ? 4 : 2;
                
                 const getRecentStart = (dayIndex) => {
                    const d = new Date(); 
                    d.setDate(d.getDate() - ((d.getDay() + 7 - dayIndex) % 7));
                     return d;
                };
                
                const baseDate = getRecentStart(dayOffset);

                const gridStartTimeMs = Date.UTC(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate(), 5, 0, 0);
                const activeStartMs = gridStartTimeMs + (12 * 3600000);
                const activeEndMs = activeStartMs + (7 * 24 * 3600000);
                return { gridStartTimeMs, activeStartMs, activeEndMs };
            }, [activeCycleType]);

            // --- CRITICAL FIX: Define hoursSinceLast HERE ---
            // It MUST be defined before any hook that uses it (rtStats, etc.)
            let hoursSinceLast = 0;
            const lastPost = posts.length > 0 ? posts[0] : null;
            const lastPostTime = lastPost && lastPost.createdAt ? new Date(lastPost.createdAt) : null;
            if (lastPostTime) {
                const diffMs = new Date() - lastPostTime;
                hoursSinceLast = diffMs / (1000 * 60 * 60);
            }
            // ------------------------------------------------

            useEffect(() => {
                const timer = setInterval(() => {
                    const now = new Date();
                    setCurrentTime(now);
                    const diffMs = targetDate - now;
                    const hours = Math.max(0, diffMs / (1000 * 60 * 60));
                    setHoursToTarget(hours);
                }, 1000);
                return () => clearInterval(timer);
            }, [targetDate]);

            useEffect(() => {
                if (hoursToTarget > 0 && !predictInput) {
                    setPredictInput(hoursToTarget.toFixed(2));
                }
            }, [hoursToTarget]);

            useEffect(() => {
                if (!predictInput) { setParsedHours(null); return; }
                let hours = 0;
                const inputStr = predictInput.toString().trim();
                if (inputStr.includes(':')) {
                    const parts = inputStr.split(':');
                    const d = parseInt(parts[0]) || 0;
                    const h = parseInt(parts[1]) || 0;
                    if (h < 24) hours = (d * 24) + h;
                } else if (!inputStr.includes('.') && inputStr.length >= 3 && inputStr.length <= 4) {
                    const d = parseInt(inputStr.slice(0, -2));
                    const h = parseInt(inputStr.slice(-2));
                    if (h < 24) hours = (d * 24) + h;
                    else hours = parseFloat(inputStr); 
                } else {
                    hours = parseFloat(inputStr);
                }
                if (!isNaN(hours) && hours > 0) setParsedHours(hours);
                else setParsedHours(null);
            }, [predictInput]);

            useEffect(() => {
                if (!posts.length || parsedHours === null) { setPrediction(null); return; }
                const currentTotal = (typeof specialCount === 'number') ? specialCount : 0;
                const windowMs = parsedHours * 3600 * 1000;
                const timestamps = posts.map(p => new Date(p.createdAt).getTime()).sort((a, b) => a - b);
                if (timestamps.length < 10) return; 

                const startTime = timestamps[0];
                const endTime = timestamps[timestamps.length - 1];
                const totalDuration = endTime - startTime;
                if (totalDuration < windowMs) return;

                let counts = [];
                for (let t = startTime; t <= endTime - windowMs; t += 3600000) {
                    const rangeEnd = t + windowMs;
                    const count = timestamps.filter(ts => ts >= t && ts < rangeEnd).length;
                    counts.push({ count, time: t });
                }

                if (counts.length > 0) {
                    const splitIndex = Math.floor(counts.length * (2/3)); 
                    const pastData = counts.slice(0, splitIndex); 
                    const recentData = counts.slice(splitIndex); 
                    const calcAvg = (arr) => arr.length ? arr.reduce((a,b)=>a+b.count,0) / arr.length : 0;
                    const pastAvg = calcAvg(pastData);
                    const recentAvg = calcAvg(recentData);
                    
                    let weightedAvg = 0;
                    if (recentData.length > 0 && pastData.length > 0) {
                        weightedAvg = (recentAvg * 0.7) + (pastAvg * 0.3);
                    } else {
                        weightedAvg = calcAvg(counts);
                    }

                    const allCounts = counts.map(c => c.count).sort((a, b) => a - b);
                    const getPercentile = (p) => allCounts[Math.floor((allCounts.length - 1) * p)];
                    
                    const minDelta = allCounts[0];
                    const p25Delta = getPercentile(0.25);
                    const p50Delta = getPercentile(0.50);
                    const p75Delta = getPercentile(0.75);
                    const maxDelta = allCounts[allCounts.length - 1]; 
                    const avgDelta = weightedAvg;
                    const avgProb = Math.min(100, Math.max(30, 100 - Math.abs(weightedAvg - recentAvg)*5)).toFixed(0);

                    // Update ref for webhook
                    setStatsRef(prev => ({
                        ...prev,
                        predictionAvg: (weightedAvg + currentTotal).toFixed(1),
                        predictionConf: avgProb
                    }));

                    setPrediction({ 
                        min: minDelta + currentTotal, 
                        p25: p25Delta + currentTotal,
                        p50: p50Delta + currentTotal,
                        p75: p75Delta + currentTotal,
                        max: maxDelta + currentTotal, 
                        avg: (avgDelta + currentTotal).toFixed(1), 
                        hours: parsedHours.toFixed(1),
                        avgProb
                    });
                } else {
                    setPrediction(null);
                }
            }, [posts, parsedHours, specialCount]);

            const fetchFromApi = useCallback(async (retryAttempt = 0) => {
                setLoading(true);
                addLog(`Starting Main API Fetch... (Attempt ${retryAttempt + 1})`);
                const corsURL = 'https://corsproxy.io/?'; 
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000);

                try {
                    const endDate = new Date();
                    const startDate = new Date();
                    startDate.setDate(startDate.getDate() - 90); 
                    const postsTarget = `https://xtracker.polymarket.com/api/users/elonmusk/posts?startDate=${startDate.toISOString()}&endDate=${endDate.toISOString()}`;
                    const postsUrl = `${corsURL}${encodeURIComponent(postsTarget)}&_t=${Date.now()}`;
                    
                    addLog("Requesting history (90d)...");
                    const postsRes = await fetch(postsUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);

                    if (!postsRes.ok) {
                         addLog(`Main API Error: ${postsRes.status}`);
                         if (postsRes.status === 403) setShowControls(true); 
                         throw new Error(`連線錯誤 HTTP ${postsRes.status}`);
                    }
                    const postsJson = await postsRes.json();
                    let postsData = postsJson.data || [];
                    addLog(`Received ${postsData.length} posts.`);

                    if (Array.isArray(postsData) && postsData.length > 0) {
                        processData(postsData);
                        setDataSource("Live API (90 Days)");
                        setShowControls(false); 
                        setErrorMsg(null);
                        addLog("Data processed successfully.");
                        try {
                            const userTarget = "https://xtracker.polymarket.com/api/users/elonmusk";
                            const userRes = await fetch(`${corsURL}${encodeURIComponent(userTarget)}`);
                            if (userRes.ok) {
                                const uData = await userRes.json();
                                if (uData.success) setUserInfo(uData.data);
                            }
                        } catch(e) {}
                    } else {
                        addLog("Warning: No posts found.");
                        throw new Error("No data found");
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    console.error("Main fetch failed:", err);
                    if (err.name === 'AbortError') {
                        addLog("Timeout (20s) reached.");
                        addLog("Retrying in 1s...");
                        setTimeout(() => fetchFromApi(retryAttempt + 1), 1000);
                        return; 
                    } else {
                        addLog(`Error: ${err.message}`);
                        setErrorMsg(`${err.message}`);
                        setShowControls(true); 
                    }
                } finally {
                    setLoading(false);
                }
            }, []);

            const fetchSpecialData = useCallback(async () => {
                if (isFetchingSpecialRef.current) return;
                isFetchingSpecialRef.current = true;

                setLoadingSpecial(true);
                const targetUrl = "https://xtracker.polymarket.com/api/users/elonmusk/posts?startDate=2025-12-26T17:00:00.000Z&endDate=2026-01-02T17:00:59.000Z";
                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}&_t=${Date.now()}`;
                
                try {
                    const response = await fetch(proxyUrl, {
                        "headers": { "accept": "application/json", "cache-control": "no-cache", "pragma": "no-cache" },
                        "method": "GET"
                    });
                    if (response.ok) {
                        const json = await response.json();
                        if (json.success && Array.isArray(json.data)) {
                            const newCount = json.data.length;
                            if (prevSpecialCountRef.current !== null && newCount !== prevSpecialCountRef.current) {
                                setIsNewPost(true);
                                setTimeout(() => setIsNewPost(false), 2000); 
                                addLog("New post detected! Refreshing...");
                                
                                // Trigger Alarm & Notification
                                playAlarm();
                                const currentRate = statsRef.velocity24h || "0.00";
                                sendSystemNotification(newCount, currentRate + "/h");

                                const s = statsRef; 
                                const msg = `發文數更新:${newCount}預測${s.predictionAvg}&${s.predictionConf}    速率:${s.velocity12H}&${s.projectedCurrent}&${s.projected7Day}總預估值${s.heatmapMin},${s.heatmapAvg},${s.heatmapMax}區間機率預測:${s.rangeProbs}`;
                                sendWebhook(msg);
                                fetchFromApi(); 
                            }
                            prevSpecialCountRef.current = newCount;
                            setSpecialCount(newCount);
                            setSpecialLastFetchTime(new Date());
                            setIsOffline(false); 
                        } else { setIsOffline(true); }
                    } else { setIsOffline(true); }
                } catch (error) { setIsOffline(true); } 
                finally { 
                    setLoadingSpecial(false); 
                    isFetchingSpecialRef.current = false; 
                }
            }, [fetchFromApi, webhookUrl, statsRef, playAlarm, sendSystemNotification]); 

            useEffect(() => {
                addLog("System Init...");
                fetchSpecialData();
                const interval = setInterval(fetchSpecialData, 5000); 
                return () => clearInterval(interval);
            }, [fetchSpecialData]);

            useEffect(() => { fetchFromApi(0); }, [fetchFromApi]);

            const processData = (rawData) => {
                const sorted = [...rawData].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                setPosts(sorted);
                setLastUpdated(new Date());
            };

            // Trigger translation when posts update
            useEffect(() => {
                if (posts.length > 0 && googleApiKey) {
                    const topPosts = posts.slice(0, visiblePostsCount);
                    // Debounce slightly to avoid rapid calls
                    const timer = setTimeout(() => {
                        translatePostsBatch(topPosts);
                    }, 1000);
                    return () => clearTimeout(timer);
                }
            }, [posts, googleApiKey, translatePostsBatch, visiblePostsCount]);

            // ... (CSV Parsing Logic - same as above) ...
            const parseCSVChunked = (text, onComplete) => {
                const lines = text.split(/\r?\n/);
                const total = lines.length;
                let current = 1; 
                const chunkSize = 200; 
                const results = [];
                
                const parseLine = (line) => {
                    const result = [];
                    let start = 0;
                    let inQuotes = false;
                    for (let i = 0; i < line.length; i++) {
                        if (line[i] === '"') { inQuotes = !inQuotes; } 
                        else if (line[i] === ',' && !inQuotes) { result.push(line.substring(start, i)); start = i + 1; }
                    }
                    result.push(line.substring(start));
                    return result.map(s => s.replace(/^"|"$/g, '').replace(/""/g, '"'));
                };

                if (total < 2) { onComplete([]); return; }

                const headers = parseLine(lines[0]);
                const idIdx = headers.findIndex(h => h.includes("Tweet ID"));
                const contentIdx = headers.findIndex(h => h.includes("Content") || h.toLowerCase() === 'content');
                const dateIdx = headers.findIndex(h => h.includes("Posted At") || h.includes("Posted Date"));
                const timeIdx = headers.findIndex(h => h.includes("Posted Time"));
                const fullTimeIdx = headers.findIndex(h => h.includes("TIME"));

                if (contentIdx === -1) {
                     setErrorMsg("CSV 格式錯誤: 找不到 Content 欄位");
                     onComplete([]);
                     return;
                }
                
                // Allow missing ID (auto-generate)
                // Require Date (either Posted At or TIME)
                if (dateIdx === -1 && fullTimeIdx === -1) {
                    setErrorMsg("CSV 格式錯誤: 缺少時間欄位");
                    onComplete([]);
                    return;
                }

                const processChunk = () => {
                    const end = Math.min(current + chunkSize, total);
                    for (let i = current; i < end; i++) {
                        if (!lines[i].trim()) continue;
                        try {
                            const cols = parseLine(lines[i]);
                            let dateStr = "";
                            
                            // Try TIME first
                            if (fullTimeIdx !== -1 && cols[fullTimeIdx]) {
                                dateStr = cols[fullTimeIdx];
                            } else if (dateIdx !== -1) {
                                dateStr = cols[dateIdx];
                                if (dateStr && !dateStr.includes(":") && timeIdx !== -1) { 
                                    dateStr += " " + cols[timeIdx]; 
                                }
                            }
                            
                            const dateObj = new Date(dateStr);
                            const content = cols[contentIdx];
                            
                            // Generate ID if missing
                            const id = (idIdx !== -1 && cols[idIdx]) ? cols[idIdx] : `csv-${i}-${Date.now()}`;

                            if (!isNaN(dateObj) && content) {
                                results.push({ id, content, createdAt: dateObj.toISOString() });
                            }
                        } catch (e) {
                            console.warn("Skipping bad CSV line", i);
                        }
                    }
                    current = end;
                    if (current < total) {
                        if (current % 1000 === 0) addLog(`Processing CSV... ${(current/total*100).toFixed(0)}%`);
                        setTimeout(processChunk, 0); 
                    } else {
                        onComplete(results);
                    }
                };
                processChunk();
            };

            const calibrateAndMerge = (currentApiData, newCsvData) => {
                addLog(`Merging... API: ${currentApiData.length}, CSV: ${newCsvData.length}`);
                let timeOffset = 0;
                let matched = false;
                const sortedApi = [...currentApiData].sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt));
                
                for (let apiPost of sortedApi) {
                    const match = newCsvData.find(c => c.content.trim() === apiPost.content.trim());
                    if (match) {
                        const apiTime = new Date(apiPost.createdAt).getTime();
                        const csvTime = new Date(match.createdAt).getTime();
                        timeOffset = apiTime - csvTime;
                        addLog(`Time Calibration Offset: ${timeOffset}ms (${(timeOffset/60000).toFixed(1)} mins)`);
                        matched = true;
                        break; 
                    }
                }
                if (!matched) addLog("Warning: No matching content found for calibration.");

                const postMap = new Map();
                currentApiData.forEach(p => postMap.set(p.id, p));
                newCsvData.forEach(p => {
                    let correctedTime = p.createdAt;
                    if (matched && timeOffset !== 0) {
                         correctedTime = new Date(new Date(p.createdAt).getTime() + timeOffset).toISOString();
                    }
                    const newPost = { ...p, createdAt: correctedTime };
                    if (!postMap.has(newPost.id)) {
                        postMap.set(newPost.id, newPost);
                    }
                });
                
                const finalPosts = Array.from(postMap.values()).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                addLog(`Merge Complete. Total: ${finalPosts.length}`);
                return finalPosts;
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                addLog(`Reading CSV: ${file.name}`);
                setLoading(true); 
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const text = evt.target.result;
                    parseCSVChunked(text, (parsedCsvData) => {
                        if (parsedCsvData.length > 0) {
                            const mergedData = calibrateAndMerge(posts, parsedCsvData);
                            setPosts(mergedData);
                            setDataSource(`Merged (API + ${file.name})`);
                            setShowControls(false);
                            setErrorMsg(null);
                        } else {
                            setErrorMsg("CSV 解析失敗");
                            addLog("CSV parsing failed.");
                        }
                        setLoading(false);
                    });
                };
                reader.onerror = () => { setErrorMsg("檔案讀取錯誤"); setLoading(false); };
                reader.readAsText(file);
            };

            const simpleTranslate = (text) => {
                if (!text) return "";
                let t = text;
                t = t.replace(/RT /g, "【轉推】");
                t = t.replace(/Space/gi, "太空");
                t = t.replace(/Mars/gi, "火星");
                t = t.replace(/crypto/gi, "加密貨幣");
                t = t.replace(/doge/gi, "狗狗幣");
                t = t.replace(/AI/g, "人工智慧");
                t = t.replace(/future/gi, "未來");
                return t;
            };

            const rtStats = useMemo(() => {
                if (posts.length === 0) return { rt: 0, original: 0, rtPercent: 0, total: 0 };
                const now = new Date();
                const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                const recent = posts.filter(p => new Date(p.createdAt) >= oneDayAgo);
                if (recent.length === 0) return { rt: 0, original: 0, rtPercent: 0, total: 0 };
                const rtCount = recent.filter(p => p.content && (p.content.trim().startsWith("RT @") || p.content.trim().startsWith("RT "))).length;
                const total = recent.length;
                const rtPercent = Math.round((rtCount / total) * 100);
                return { rt: rtCount, original: total - rtCount, rtPercent, total };
            }, [posts, currentTime]);

            const historicalStats = useMemo(() => {
                if (posts.length === 0) return {};
                const windows = [1, 6, 12, 24, 48, 72, 96, 120, 144, 168]; 
                const res = {};
                const timestamps = posts.map(p => new Date(p.createdAt).getTime()).sort((a, b) => a - b);
                const start = timestamps[0];
                const end = timestamps[timestamps.length - 1]; 
                windows.forEach(win => {
                    const winMs = win * 60 * 60 * 1000;
                    let max = 0, min = Infinity, sum = 0, samples = 0;
                    let maxTime = null; let minTime = null;
                    let minCount = 0; let maxCount = 0;
                    const searchLimit = end - winMs;
                    for (let t = start; t <= searchLimit; t += 3600000) {
                        const count = timestamps.filter(ts => ts >= t && ts < t + winMs).length;
                        if (count > max) { max = count; maxTime = t; }
                        if (count < min) { min = count; minTime = t; }
                        sum += count;
                        samples++;
                    }
                    if (min === Infinity) { min = 0; minTime = start; }
                     for (let t = start; t <= searchLimit; t += 3600000) {
                        const count = timestamps.filter(ts => ts >= t && ts < t + winMs).length;
                        if (count === min) minCount++;
                        if (count === max) maxCount++;
                    }
                    res[win] = { 
                        avg: samples > 0 ? sum / samples : 0, 
                        max, min, maxTime, minTime, samples, 
                        totalSum: sum,
                        minFreq: samples > 0 ? ((minCount / samples) * 100).toFixed(0) : 0,
                        maxFreq: samples > 0 ? ((maxCount / samples) * 100).toFixed(0) : 0
                    };
                });
                return res;
            }, [posts]);

            const realTimeComparison = useMemo(() => {
                if (posts.length === 0) return null;
                const now = new Date();
                const getCount = (ref, h) => {
                    const start = new Date(ref.getTime() - h * 3600000);
                    return posts.filter(p => new Date(p.createdAt) >= start && new Date(p.createdAt) <= ref).length;
                };
                const data = {};
                [1, 6, 12, 24, 48, 72, 96, 120, 144, 168].forEach(h => {
                    const current = getCount(now, h);
                    const history = [];
                    for(let d=1; d<=7; d++) history.push(getCount(new Date(now.getTime() - d*86400000), h));
                    const sum7d = history.reduce((a,c)=>a+c,0);
                    const avg7d = sum7d/7;
                    const ratio7d = avg7d>0 ? (current/avg7d)*100 : (current>0?100:0);
                    data[h] = { current, history, avg7d: avg7d.toFixed(1), ratio7d: ratio7d.toFixed(0) };
                });
                return data;
            }, [posts, currentTime]);

            const velocityStats = useMemo(() => {
                if (!historicalStats[1] || !realTimeComparison) return {};
                const res = {};
                [1, 6, 12, 24, 48, 72, 96, 120, 144, 168].forEach(h => {
                    const current = realTimeComparison[h].current;
                    const stats = historicalStats[h];
                    const avg = stats.avg;
                    let pos = 0;
                    if (stats.max > stats.min) pos = ((current - stats.min) / (stats.max - stats.min)) * 100;
                    else if (current > 0) pos = 100;
                    pos = Math.max(0, Math.min(100, pos));
                    const ratio = avg > 0 ? (current / avg) * 100 : (current > 0 ? 100 : 0);
                    
                    res[h] = { 
                        current, 
                        avg: avg.toFixed(1), 
                        min: stats.min, 
                        max: stats.max, 
                        pos, 
                        ratio: ratio.toFixed(0),
                        maxTime: stats.maxTime,
                        minTime: stats.minTime,
                        samples: stats.samples,
                        totalSum: stats.totalSum,
                        minFreq: stats.minFreq,
                        maxFreq: stats.maxFreq
                    };
                });
                return res;
            }, [historicalStats, realTimeComparison]);

            // NEW: Update statsRef with 24h velocity for notification
            useEffect(() => {
                if (velocityStats && velocityStats[24]) {
                    const v24 = velocityStats[24];
                    const rate = (v24.current / 24).toFixed(2);
                    setStatsRef(prev => ({ ...prev, velocity24h: rate }));
                }
            }, [velocityStats]);

            const lastLongSilence = useMemo(() => {
                if (posts.length < 2) return null;
                const now = new Date();
                const sorted = [...posts].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                
                for (let i = 0; i < sorted.length - 1; i++) {
                    const currentPostTime = new Date(sorted[i].createdAt);
                    const prevPostTime = new Date(sorted[i+1].createdAt);
                    const diffHours = (currentPostTime - prevPostTime) / 3600000;
                    
                    if (diffHours > 3) {
                         const endedAgo = (now - currentPostTime) / 3600000;
                         const fmt = (d) => d.toLocaleDateString('en-US', {
                            timeZone: 'America/New_York', month:'numeric', day:'numeric'
                         }) + ' ' + d.toLocaleTimeString('en-US', {
                            timeZone: 'America/New_York', hour12:false, hour:'2-digit', minute:'2-digit'
                         });
                         return {
                             endedAgo: endedAgo.toFixed(1),
                             duration: diffHours.toFixed(1),
                             range: `${fmt(prevPostTime)}~${fmt(currentPostTime)}`
                         };
                    }
                }
                return null;
            }, [posts, currentTime]);


            const tacticalData = useMemo(() => {
                if (posts.length < 2) return null; 
                const sorted = [...posts].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                const currentS = hoursSinceLast;

                const calcP = (h) => {
                    const gaps = [];
                    for (let i = 0; i < sorted.length - 1; i++) {
                        const diff = (new Date(sorted[i].createdAt) - new Date(sorted[i+1].createdAt)) / 3600000;
                        if (diff > 0) gaps.push(diff);
                    }
                    const denom = gaps.filter(g => g >= currentS).length;
                    if (denom === 0) return 0;
                    const num = gaps.filter(g => g >= currentS && g <= currentS + h).length;
                    return (num / denom) * 100;
                };

                const timeOfDaySamples = [];
                const checkTimeBase = currentTime; 
                const dayMs = 24 * 60 * 60 * 1000;
                for (let d = 1; d <= 90; d++) {
                    const historicalNow = new Date(checkTimeBase.getTime() - d * dayMs);
                    const postsBefore = posts.filter(p => new Date(p.createdAt) <= historicalNow);
                    if (postsBefore.length > 0) {
                        const lastPostBeforeNow = postsBefore[0];
                        const historicalSilence = (historicalNow - new Date(lastPostBeforeNow.createdAt)) / 3600000;
                        if (historicalSilence >= currentS) {
                            const postsAfter = posts.filter(p => new Date(p.createdAt) > historicalNow);
                            let totalSilenceDuration = 0;
                            if (postsAfter.length > 0) {
                                const nextPost = postsAfter[postsAfter.length - 1];
                                totalSilenceDuration = (new Date(nextPost.createdAt) - new Date(lastPostBeforeNow.createdAt)) / 3600000;
                            } else { continue; }
                            timeOfDaySamples.push(totalSilenceDuration);
                        }
                    }
                }
                const totalSamples = timeOfDaySamples.length; 
                const calcTimeProb = (targetTotalH) => {
                    if (totalSamples === 0) return 0;
                    if (targetTotalH <= currentS) return 100;
                    const count = timeOfDaySamples.filter(duration => duration > targetTotalH).length;
                    return ((count / totalSamples) * 100).toFixed(0);
                };

                const longSilenceProbs = {
                    p4h: calcTimeProb(4), p6h: calcTimeProb(6), p8h: calcTimeProb(8),
                    p10h: calcTimeProb(10), p12h: calcTimeProb(12), sampleSize: totalSamples 
                };
                
                let status = "正常活動";
                let statusColor = "text-emerald-400";
                let advice = "監控中，無異常。";
                if (currentS < 0.5) { status = "🔥 剛剛發文"; statusColor = "text-red-500 font-bold glow-text"; advice = "目標剛發文。密切注意是否開啟連續發文模式。"; }
                else if (currentS > 6 && currentS < 9) { status = "🛌 可能睡眠中"; statusColor = "text-yellow-400"; advice = "靜默 > 6 小時。根據歷史作息，醒來後常伴隨高頻發文。"; }
                
                return { probs: [calcP(1), calcP(2), calcP(3), calcP(4)], longSilenceProbs, status, statusColor, advice };
            }, [posts, hoursSinceLast, currentTime]);

            return (
                <div className="min-h-screen pb-safe-area-bottom">
                    {/* Header */}
                    <div className="sticky top-0 z-50 bg-black/90 backdrop-blur border-b border-gray-800 px-4 py-3 flex justify-between items-center shadow-lg">
                        <div className="flex items-center space-x-2">
                            <button onClick={() => setShowControls(!showControls)} className="focus:outline-none">
                                {userInfo ? <img src={userInfo.avatarUrl} alt="User" className="w-8 h-8 rounded-full border border-gray-600" /> : <Terminal className="w-6 h-6 text-sky-500" />}
                            </button>
                            <div>
                                <div className="font-bold tracking-tight text-gray-100 leading-none flex items-center">
                                    ELON TACTICAL {userInfo?.verified && <CheckCircle className="w-3 h-3 text-blue-400 ml-1" />}
                                </div>
                                <div className={`text-[10px] font-mono tracking-wider ${dataSource.includes("Live") ? "text-emerald-500" : "text-sky-500"}`}>● {dataSource.toUpperCase()}</div>
                            </div>
                        </div>
                        <div className="flex flex-col items-end">
                            <div className="flex items-baseline space-x-1">
                                <span className="text-sm text-emerald-500 font-bold mr-1">{formatDateET(currentTime)}</span>
                                <span className="text-2xl font-mono font-bold text-emerald-400 leading-none">{formatTimeET(currentTime)}</span>
                                <span className="text-xs text-emerald-600 font-bold">ET</span>
                                <span className="text-xs text-gray-400">({formatWeekdayET(currentTime)})</span>
                            </div>
                            <div className="flex items-center text-[10px] text-sky-400 mt-1 bg-sky-900/20 px-1 rounded">
                                <Target className="w-3 h-3 mr-1" />
                                倒數: {hoursToTarget > 0 ? `${Math.floor(hoursToTarget)}h ${Math.floor((hoursToTarget % 1) * 60)}m` : '已過期'}
                            </div>
                        </div>
                    </div>

                    {/* Controls */}
                    <div className="bg-[#0a0a0a] border-b border-gray-900 transition-all duration-300 ease-in-out overflow-hidden" style={{maxHeight: showControls ? '400px' : '0', opacity: showControls ? 1 : 0}}>
                        <div className="px-4 py-2 space-y-2">
                                <div className="flex justify-between items-center text-xs text-red-400 mb-1">
                                    <span>⚠️ {errorMsg || "連線需注意"}</span>
                                    <button onClick={() => setShowControls(false)} className="text-gray-500">隱藏</button>
                                </div>
                                <div className="flex gap-2">
                                     <button onClick={fetchFromApi} disabled={loading} className="w-full bg-sky-900/30 text-sky-400 border border-sky-800 py-3 rounded text-sm font-medium flex justify-center items-center mb-2">
                                        {loading ? <RefreshCw className="w-4 h-4 animate-spin mr-2" /> : "重試連線"}
                                    </button>
                                    <button 
                                        onClick={async () => {
                                            playAlarm();
                                            if (!("Notification" in window)) {
                                                addLog("此瀏覽器不支援通知");
                                                return;
                                            }
                                            
                                            // Check and request permission
                                            if (Notification.permission !== "granted") {
                                                addLog("正在請求通知權限...");
                                                const permission = await Notification.requestPermission();
                                                if (permission !== "granted") {
                                                    addLog("通知權限被拒絕");
                                                    return;
                                                }
                                            }
                                            
                                            sendSystemNotification(specialCount || 0, (statsRef.velocity24h || "0.0") + "/h");
                                            addLog("已發送測試通知");
                                        }} 
                                        className="w-full bg-emerald-900/30 text-emerald-400 border border-emerald-800 py-3 rounded text-sm font-medium flex justify-center items-center mb-2"
                                    >
                                        <Bell className="w-4 h-4 mr-2" />
                                        測試通知 (Test)
                                    </button>
                                </div>
                                
                                <div className="border-t border-gray-800 pt-2 mb-2">
                                    <label className="block text-[10px] text-gray-500 mb-1 flex items-center">
                                        <Languages className="w-3 h-3 mr-1" /> Google Translate API Key
                                    </label>
                                    <input 
                                        type="password" 
                                        value={googleApiKey}
                                        onChange={(e) => setGoogleApiKey(e.target.value)}
                                        placeholder="貼上 API Key (AIza...)" 
                                        className="bg-gray-900 border border-gray-700 text-white text-xs rounded px-2 py-1 w-full focus:outline-none focus:border-emerald-500 mb-1" 
                                    />
                                    <div className="text-[9px] text-gray-600">填入 Key 後自動翻譯最新 10 篇貼文</div>
                                </div>

                                <div className="border-t border-gray-800 pt-2 mb-2">
                                    <label className="block text-[10px] text-gray-500 mb-1 flex items-center">
                                        <Send className="w-3 h-3 mr-1" /> LINE / Webhook 網址
                                    </label>
                                    <div className="flex gap-2">
                                         <input 
                                            type="text" 
                                            value={webhookUrl}
                                            onChange={(e) => setWebhookUrl(e.target.value)}
                                            placeholder="https://..." 
                                            className="bg-gray-900 border border-gray-700 text-white text-xs rounded px-2 py-1 w-full focus:outline-none focus:border-emerald-500" 
                                        />
                                        <button onClick={() => sendWebhook("🔔 測試訊息: 連線正常！")} className="bg-gray-800 text-gray-300 border border-gray-700 px-3 rounded text-xs hover:bg-gray-700 whitespace-nowrap">
                                            測試
                                        </button>
                                    </div>
                                    <div className="text-[9px] text-gray-600 mt-1">偵測到新發文數時自動發送通知</div>
                                </div>

                                <label className="flex items-center justify-center w-full bg-emerald-900/30 text-emerald-400 border border-emerald-800 py-3 rounded text-sm font-medium cursor-pointer">
                                    <FileText className="w-4 h-4 mr-2" />
                                    <span>匯入 .csv 檔案</span>
                                    <input type="file" accept=".csv" onChange={handleFileUpload} className="hidden" />
                                </label>
                        </div>
                    </div>

                    {posts.length > 0 ? (
                        <div className="p-4 space-y-4">
                            {/* Main Stats Card */}
                            <div className="mobile-card p-5 relative overflow-hidden">
                                <div className="absolute top-0 right-0 p-4 opacity-10"><Clock className="w-24 h-24 text-white" /></div>
                                <div className="grid grid-cols-2 gap-4">
                                    {/* Silence */}
                                    <div className="stat-divider pr-4">
                                        <div className="flex justify-between items-center mb-1">
                                            <div className="text-gray-400 text-[10px] uppercase tracking-widest">目前靜默 (Silence)</div>
                                        </div>
                                        <div className={`text-4xl font-bold font-mono my-1 ${hoursSinceLast > 6 ? 'text-red-400' : 'text-white'}`}>
                                            {hoursSinceLast.toFixed(2)}<span className="text-sm text-gray-500 ml-1">hr</span>
                                        </div>
                                        <div className="text-[10px] text-gray-400 flex items-center">
                                            <span className="mr-1">Latest:</span>
                                            <span className="font-mono text-sky-400">{lastPostTime ? lastPostTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit', hour12: false}) : '--'}</span>
                                        </div>
                                        {lastLongSilence && (
                                            <div className="text-[9px] text-gray-500 mt-1 pt-1 border-t border-gray-800">
                                                上一次 &gt;3h: <span className="text-gray-300 font-mono text-[10px]">{lastLongSilence.range}</span> 
                                                <span className="text-gray-600 ml-1">({lastLongSilence.duration}h)</span>
                                            </div>
                                        )}
                                        <div className="mt-2 pt-2 border-t border-gray-800">
                                            <div className="text-[9px] text-gray-500 mb-1 flex items-center"><Moon className="w-2 h-2 mr-1" />慣性沉默機率 (時間因素)</div>
                                            <div className="grid grid-cols-5 gap-1">
                                                {tacticalData && (
                                                    <>
                                                        <SilenceProbBadge label=">4h" prob={tacticalData.longSilenceProbs.p4h} />
                                                        <SilenceProbBadge label=">6h" prob={tacticalData.longSilenceProbs.p6h} />
                                                        <SilenceProbBadge label=">8h" prob={tacticalData.longSilenceProbs.p8h} />
                                                        <SilenceProbBadge label=">10h" prob={tacticalData.longSilenceProbs.p10h} />
                                                        <SilenceProbBadge label=">12h" prob={tacticalData.longSilenceProbs.p12h} />
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                    {/* Latest Count */}
                                    <div className="pl-2">
                                        <div className="flex justify-between items-center mb-1">
                                            <div className="text-gray-400 text-[10px] uppercase tracking-widest">最新發文數 (Latest)</div>
                                            <button onClick={fetchSpecialData} className="text-gray-500 hover:text-white transition p-1 rounded-full bg-gray-800/50">
                                                <RefreshCw className={`w-3 h-3 ${loadingSpecial ? 'animate-spin' : ''}`} />
                                            </button>
                                        </div>
                                        <div className={`text-4xl font-bold font-mono my-1 ${isOffline ? 'text-gray-400' : 'text-white'} ${isNewPost ? 'animate-flash' : ''}`}>
                                            {specialCount !== null ? specialCount : "--"}
                                            <span className="text-sm text-gray-500 ml-1">篇</span>
                                        </div>
                                        <div className="flex items-center text-[10px] text-gray-500 mt-1">
                                            {isOffline && <AlertOctagon className="w-3 h-3 mr-1 text-yellow-500" />}
                                            <Zap className={`w-3 h-3 mr-1 ${!isOffline && isNewPost ? 'animate-bounce text-sky-400' : (isOffline ? 'text-gray-600' : 'text-sky-500')}`} />
                                            <span>
                                                {specialLastFetchTime ? 
                                                    `更新於 ${specialLastFetchTime.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false})} ${isOffline ? '(延遲)' : ''}` 
                                                    : '等待...'}
                                            </span>
                                        </div>
                                        {/* Prediction Input */}
                                        <div className="mt-3 pt-2 border-t border-gray-800/50 flex flex-col">
                                            <div className="flex items-center mb-1">
                                                <Calculator className="w-3 h-3 text-sky-500 mr-2" />
                                                <span className="text-[10px] text-gray-400">預測時數 (智慧格式):</span>
                                            </div>
                                            <input type="text" placeholder="例: 1.5 或 0115 (1天15時)" className="bg-gray-900 border border-gray-700 text-white text-xs rounded px-2 py-1 w-full focus:outline-none focus:border-sky-500" value={predictInput} onChange={(e) => setPredictInput(e.target.value)} />
                                            {parsedHours && <div className="text-[9px] text-emerald-500 mt-0.5 text-right">解析: {parsedHours.toFixed(1)} 小時</div>}
                                        </div>
                                    </div>
                                </div>
                                <div className="mt-4 pt-3 border-t border-gray-800 text-sm text-gray-400 leading-relaxed">
                                    <span className="text-sky-500 font-bold">戰術提示：</span>
                                    {prediction ? (
                                        <span className="text-white animate-in fade-in block">
                                            <div className="flex items-center justify-between mb-2">
                                                <span className="text-sky-400 font-bold text-sm">未來 {prediction.hours} 小時加權預測 <span className="text-xs font-normal text-gray-400">(含目前總數)</span>:</span>
                                                <span className="text-[10px] text-gray-500 bg-gray-900 px-2 py-0.5 rounded-full border border-gray-800">近期權重 70%</span>
                                            </div>
                                            <div className="space-y-2">
                                                <div className="grid grid-cols-4 gap-2 text-center text-xs">
                                                    <div className="bg-gray-800/50 rounded p-2 border border-gray-700 flex flex-col items-center justify-center">
                                                        <div className="text-[9px] text-gray-400">Min (0%)</div>
                                                        <div className="text-emerald-400 font-mono font-bold text-lg">{prediction.min}</div>
                                                    </div>
                                                    <div className="bg-gray-800/50 rounded p-2 border border-gray-700 flex flex-col items-center justify-center">
                                                        <div className="text-[9px] text-gray-400">25%</div>
                                                        <div className="text-white font-mono font-bold text-lg">{prediction.p25}</div>
                                                    </div>
                                                    <div className="bg-gray-800/50 rounded p-2 border border-gray-700 flex flex-col items-center justify-center">
                                                        <div className="text-[9px] text-gray-400">50%</div>
                                                        <div className="text-white font-mono font-bold text-lg">{prediction.p50}</div>
                                                    </div>
                                                    <div className="bg-gray-800/50 rounded p-2 border border-gray-700 flex flex-col items-center justify-center">
                                                        <div className="text-[9px] text-gray-400">75%</div>
                                                        <div className="text-white font-mono font-bold text-lg">{prediction.p75}</div>
                                                    </div>
                                                </div>
                                                <div className="grid grid-cols-3 gap-2 text-center text-xs">
                                                    <div className="bg-gray-800/50 rounded p-2 border border-gray-700 flex flex-col items-center justify-center">
                                                        <div className="text-[9px] text-gray-400">Max (100%)</div>
                                                        <div className="text-red-400 font-mono font-bold text-xl">{prediction.max}</div>
                                                    </div>
                                                    <div className="bg-sky-900/20 rounded p-2 border border-sky-800 flex flex-col items-center justify-center">
                                                        <div className="text-[9px] text-sky-400 font-bold">W.AVG</div>
                                                        <div className="text-white font-mono font-bold text-xl">{prediction.avg}</div>
                                                    </div>
                                                    <div className="bg-emerald-900/20 rounded p-2 border border-emerald-800 flex flex-col items-center justify-center">
                                                        <div className="text-[9px] text-emerald-400 uppercase">Conf</div>
                                                        <div className="text-xl font-bold text-emerald-400 font-mono">{prediction.avgProb}%</div>
                                                    </div>
                                                </div>
                                            </div>
                                        </span>
                                    ) : (
                                        tacticalData?.advice || "輸入時數以開始預測..." 
                                    )}
                                </div>
                            </div>

                            {/* Split View */}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {/* Velocity */}
                                <div className="mobile-card px-4 py-2">
                                    <h3 className="text-sm text-gray-500 uppercase mt-2 mb-1 flex items-center justify-between">
                                        <div className="flex items-center"><Trending className="w-3 h-3 mr-1" /> 速率強度 (Range)</div>
                                        <div className="text-[9px] text-gray-600 font-normal">點擊數值查看計算細節</div>
                                    </h3>
                                    {velocityStats[1] && (
                                        <>
                                            <RateRow label="1H" hours={1} data={velocityStats[1]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                            <RateRow label="6H" hours={6} data={velocityStats[6]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                            <RateRow label="12H" hours={12} data={velocityStats[12]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                            <RateRow label="1天" hours={24} data={velocityStats[24]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                            <RateRow label="2天" hours={48} data={velocityStats[48]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                            <RateRow label="3天" hours={72} data={velocityStats[72]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                            <RateRow label="4天" hours={96} data={velocityStats[96]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                            <RateRow label="5天" hours={120} data={velocityStats[120]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                            <RateRow label="6天" hours={144} data={velocityStats[144]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                            <RateRow label="7天" hours={168} data={velocityStats[168]} remainingHours={hoursToTarget} currentTotal={specialCount} totalPosts={posts.length} onDetailClick={setSelectedStatDetail} />
                                        </>
                                    )}
                                </div>
                                {/* History */}
                                <div className="mobile-card px-4 py-2 overflow-x-auto hide-scroll">
                                    <div className="min-w-[320px]">
                                        <h3 className="text-sm text-sky-500 uppercase mt-2 mb-1 flex items-center justify-between">
                                            <div className="flex items-center"><History className="w-3 h-3 mr-1" /> 歷史回推 (1~7 Days)</div>
                                            <div className="text-[9px] text-gray-600">Now vs Past</div>
                                        </h3>
                                        {realTimeComparison && (
                                            <>
                                                <HistoryCompareRow label="1H" data={realTimeComparison[1]} />
                                                <HistoryCompareRow label="6H" data={realTimeComparison[6]} />
                                                <HistoryCompareRow label="12H" data={realTimeComparison[12]} />
                                                <HistoryCompareRow label="1天" data={realTimeComparison[24]} />
                                                <HistoryCompareRow label="2天" data={realTimeComparison[48]} />
                                                <HistoryCompareRow label="3天" data={realTimeComparison[72]} />
                                                <HistoryCompareRow label="4天" data={realTimeComparison[96]} />
                                                <HistoryCompareRow label="5天" data={realTimeComparison[120]} />
                                                <HistoryCompareRow label="6天" data={realTimeComparison[144]} />
                                                <HistoryCompareRow label="7天" data={realTimeComparison[168]} />
                                            </>
                                        )}
                                    </div>
                                </div>
                            </div>

                             {/* Weekly Heatmap */}
                            <WeeklyHeatmap posts={posts} liveCount={specialCount} setStatsRef={setStatsRef} />

                            {/* Chart Section */}
                            
                            {/* Last 10 Posts & RT Stats */}
                            <div className="mobile-card p-4">
                                <h3 className="text-xs text-gray-500 uppercase mb-2 flex items-center justify-between">
                                    <div className="flex items-center"><MessageSquare className="w-3 h-3 mr-1" /> 最新發文 (Display {visiblePostsCount})</div>
                                </h3>
                                
                                {rtStats && (
                                    <div className="mb-3">
                                        <div className="flex justify-between text-[10px] text-gray-400 mb-1">
                                            <span>過去 24H: 原創 {rtStats.original} 篇</span>
                                            <span>RT {rtStats.rt} 篇 ({rtStats.rtPercent}%)</span>
                                        </div>
                                        <div className="w-full h-1.5 bg-gray-800 rounded-full overflow-hidden flex">
                                            <div className="h-full bg-sky-500" style={{width: `${100 - rtStats.rtPercent}%`}}></div>
                                            <div className="h-full bg-purple-500" style={{width: `${rtStats.rtPercent}%`}}></div>
                                        </div>
                                    </div>
                                )}

                                <div className="space-y-3 max-h-80 overflow-y-auto custom-scroll pr-1">
                                    {posts.slice(0, visiblePostsCount).map((post) => (
                                        <div key={post.id} className="border-b border-gray-800 pb-2 last:border-0">
                                            <div className="flex justify-between items-start mb-1">
                                                <span className="text-[10px] text-sky-500 font-mono">
                                                    {new Date(post.createdAt).toLocaleString('en-US', {
                                                        timeZone: 'America/New_York',
                                                        month: 'numeric', 
                                                        day: 'numeric', 
                                                        hour: '2-digit', 
                                                        minute: '2-digit',
                                                        hour12: false
                                                    })} ET
                                                </span>
                                            </div>
                                            <p className="text-gray-300 text-xs leading-relaxed">
                                                {googleTranslations[post.id] ? (
                                                    <span className="animate-in fade-in text-gray-200">{googleTranslations[post.id]}</span>
                                                ) : (
                                                    simpleTranslate(post.content) || <span className="italic text-gray-600">(純圖片/轉發)</span>
                                                )}
                                            </p>
                                        </div>
                                    ))}
                                    {visiblePostsCount < posts.length && (
                                        <button 
                                            onClick={() => setVisiblePostsCount(prev => Math.min(prev + 20, posts.length))}
                                            className="w-full py-2 bg-gray-800 text-gray-400 text-xs rounded border border-gray-700 hover:bg-gray-700 hover:text-white transition mt-2 flex items-center justify-center"
                                        >
                                            <ChevronDown className="w-3 h-3 mr-1" />
                                            載入更多 ({visiblePostsCount}/{posts.length})
                                        </button>
                                    )}
                                </div>
                            </div>
                            <RangeProbabilities posts={posts} currentCount={specialCount} hoursToTarget={hoursToTarget} setStatsRef={setStatsRef} />
                            
                            {/* Insert Historical Range Stats HERE */}
                            <HistoricalRangeStats posts={posts} currentActiveWindow={currentActiveWindow} activeCycleType={activeCycleType} />

                            <div className="text-center text-[10px] text-gray-600 pt-4 pb-8 flex flex-col items-center">
                                <div>資料來源: {dataSource} | 總數: {posts.length} 筆</div>
                                <div className="mt-1">
                                    <span className="mr-2">系統更新: {lastUpdated?.toLocaleTimeString()}</span>
                                    {posts.length > 0 && (
                                        <span className="text-sky-600">
                                            最新發文: {new Date(posts[0].createdAt).toLocaleTimeString('en-US', {
                                                timeZone: 'America/New_York',
                                                month: 'numeric', 
                                                day: 'numeric', 
                                                hour: '2-digit', 
                                                minute: '2-digit',
                                                hour12: false
                                            })} ET
                                        </span>
                                    )}
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="flex flex-col items-center justify-center h-[60vh] text-gray-500 px-6 text-center relative">
                             {/* Terminal Logs in Loading Screen (Fixed Top Left) */}
                             <div className="absolute top-0 left-0 p-2 text-left w-full max-w-xs pointer-events-none">
                                <div className="bg-black/80 p-2 rounded border border-gray-800/50 backdrop-blur-sm">
                                    <div className="flex items-center text-[10px] text-gray-500 mb-1 border-b border-gray-800 pb-1">
                                        <Terminal className="w-3 h-3 mr-1" /> SYSTEM_INIT.LOG
                                    </div>
                                    {initLogs.map((log, i) => (
                                        <div key={i} className="terminal-log">
                                            {log}
                                        </div>
                                    ))}
                                    <div className="terminal-log">
                                        _<span className="terminal-cursor"></span>
                                    </div>
                                </div>
                             </div>

                             {errorMsg ? (
                                <div className="animate-in fade-in space-y-4 z-10">
                                    <h3 className="text-lg font-bold text-red-400 mb-2">系統連線異常</h3>
                                    <p className="text-sm mb-4 text-gray-400 max-w-[250px] mx-auto">{errorMsg}</p>
                                    <button 
                                        onClick={() => fetchFromApi(0)} 
                                        className="bg-red-900/30 text-red-400 border border-red-800 px-6 py-2 rounded-full text-sm font-medium hover:bg-red-900/50 transition"
                                    >
                                        重試連線
                                    </button>
                                </div>
                             ) : (
                                <div className="z-10">
                                    <RefreshCw className="w-12 h-12 mb-4 animate-spin text-sky-500 mx-auto" />
                                    <h3 className="text-lg font-bold text-gray-300 mb-2">系統初始化中...</h3>
                                    <p className="text-sm mb-6 text-gray-500">正在建立衛星連線 (Auto Connect)</p>
                                </div>
                             )}
                        </div>
                    )}
                    
                    {/* Render Modal */}
                    <StatsDetailModal detail={selectedStatDetail} onClose={() => setSelectedStatDetail(null)} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
